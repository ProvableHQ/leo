<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="leo-passes"><title>leo_passes - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="leo_passes" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0 (ded5c06cf 2025-12-08)" data-channel="1.92.0" data-search-js="search-d69d8955.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate leo_passes</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../leo_passes/index.html">leo_<wbr>passes</a><span class="version">3.4.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#leo-passes" title="leo-passes">leo-passes</a></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>leo_<wbr>passes</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/leo_passes/lib.rs.html#17-96">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="leo-passes"><a class="doc-anchor" href="#leo-passes">Â§</a>leo-passes</h2>
<p><a href="https://crates.io/crates/leo-passes"><img src="https://img.shields.io/crates/v/leo-ast.svg?color=neon" alt="Crates.io" /></a>
<a href="./LICENSE.md"><img src="https://img.shields.io/badge/License-GPLv3-blue.svg" alt="License" /></a></p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="mod" href="code_generation/index.html" title="mod leo_passes::code_generation">code_<wbr>generation</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="mod" href="common/index.html" title="mod leo_passes::common">common</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="mod" href="common_subexpression_elimination/index.html" title="mod leo_passes::common_subexpression_elimination">common_<wbr>subexpression_<wbr>elimination</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>The common subexpression elimination pass traverses the AST and removes
duplicate definitions.</dd><dt><a class="mod" href="const_prop_unroll_and_morphing/index.html" title="mod leo_passes::const_prop_unroll_and_morphing">const_<wbr>prop_<wbr>unroll_<wbr>and_<wbr>morphing</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="mod" href="const_propagation/index.html" title="mod leo_passes::const_propagation">const_<wbr>propagation</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="mod" href="dead_code_elimination/index.html" title="mod leo_passes::dead_code_elimination">dead_<wbr>code_<wbr>elimination</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>The Dead Code Elimination pass traverses the AST and eliminates unused code,
specifically assignment statements, within the boundary of <code>transition</code>s and <code>function</code>s.
The pass is run after the Function Inlining pass.</dd><dt><a class="mod" href="destructuring/index.html" title="mod leo_passes::destructuring">destructuring</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>The destructuring pass traverses the AST and destructures tuples into individual variables.
This pass assumes that tuples have a depth of 1, which is ensured by the type checking pass.</dd><dt><a class="mod" href="flattening/index.html" title="mod leo_passes::flattening">flattening</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>The flattening pass traverses the AST after the SSA pass and converts into a sequential code.
The pass flattens <code>ConditionalStatement</code>s into a sequence of <code>AssignStatement</code>s.
The pass rewrites <code>ReturnStatement</code>s into <code>AssignStatement</code>s and consolidates the returned values as a single <code>ReturnStatement</code> at the end of the function.
The pass rewrites ternary expressions over composite data types, into ternary expressions over the individual fields of the composite data type, followed by an expression constructing the composite data type.
Note that this transformation is not applied to async functions.</dd><dt><a class="mod" href="function_inlining/index.html" title="mod leo_passes::function_inlining">function_<wbr>inlining</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>The Function Inlining pass traverses the AST and inlines function at their call site.
See https://en.wikipedia.org/wiki/Inline_expansion for more information.
The pass also reorders <code>Function</code>s in a reconstructed <code>ProgramScope</code> so that they are in a post-order of the call graph.
In other words, a callee function will appear before a caller function in the order.</dd><dt><a class="mod" href="loop_unrolling/index.html" title="mod leo_passes::loop_unrolling">loop_<wbr>unrolling</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="mod" href="monomorphization/index.html" title="mod leo_passes::monomorphization">monomorphization</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>Performs monomorphization of const generic functions within a <code>ProgramScope</code>.</dd><dt><a class="mod" href="name_validation/index.html" title="mod leo_passes::name_validation">name_<wbr>validation</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="mod" href="option_lowering/index.html" title="mod leo_passes::option_lowering">option_<wbr>lowering</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>Performs lowering of <code>optional</code> types (<code>T?</code>) and <code>optional</code> expressions within a <code>ProgramScope</code>.</dd><dt><a class="mod" href="pass/index.html" title="mod leo_passes::pass">pass</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="mod" href="path_resolution/index.html" title="mod leo_passes::path_resolution">path_<wbr>resolution</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>A transform pass that resolves and reconstructs AST paths by prefixing them with the current module path.</dd><dt><a class="mod" href="processing_async/index.html" title="mod leo_passes::processing_async">processing_<wbr>async</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>The <code>ProcessingAsync</code> pass rewrites <code>async { ... }</code> blocks into standalone
<code>async function</code>s. Each block is lifted to a new top-level async function,
and the block is replaced with a call to that function.</dd><dt><a class="mod" href="processing_script/index.html" title="mod leo_passes::processing_script">processing_<wbr>script</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="mod" href="remove_unreachable/index.html" title="mod leo_passes::remove_unreachable">remove_<wbr>unreachable</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="mod" href="ssa_const_propagation/index.html" title="mod leo_passes::ssa_const_propagation">ssa_<wbr>const_<wbr>propagation</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>The SSA Const Propagation pass propagates constant values through the program.
This pass runs after SSA formation, so each variable has a unique name.</dd><dt><a class="mod" href="static_analysis/index.html" title="mod leo_passes::static_analysis">static_<wbr>analysis</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="mod" href="static_single_assignment/index.html" title="mod leo_passes::static_single_assignment">static_<wbr>single_<wbr>assignment</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>The Static Single Assignment pass traverses the AST and converts it into SSA form.
See https://en.wikipedia.org/wiki/Static_single-assignment_form for more information.
The pass also replaces <code>DefinitionStatement</code>s with <code>AssignmentStatement</code>s.
The pass also simplifies complex expressions into a sequence of <code>AssignStatement</code>s. For example, <code>(a + b) * c</code> is rewritten into <code>$var$1 = a + b; $var$2 = $var$1 * c</code>.</dd><dt><a class="mod" href="storage_lowering/index.html" title="mod leo_passes::storage_lowering">storage_<wbr>lowering</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>Performs lowering of <code>storage</code> variables and storage vectors into explicit <code>Mapping</code> operations.</dd><dt><a class="mod" href="symbol_table_creation/index.html" title="mod leo_passes::symbol_table_creation">symbol_<wbr>table_<wbr>creation</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="mod" href="type_checking/index.html" title="mod leo_passes::type_checking">type_<wbr>checking</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="mod" href="visitor/index.html" title="mod leo_passes::visitor">visitor</a></dt><dt><a class="mod" href="write_transforming/index.html" title="mod leo_passes::write_transforming">write_<wbr>transforming</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.AleoClosure.html" title="struct leo_passes::AleoClosure">Aleo<wbr>Closure</a></dt><dt><a class="struct" href="struct.AleoConstructor.html" title="struct leo_passes::AleoConstructor">Aleo<wbr>Constructor</a></dt><dt><a class="struct" href="struct.AleoFinalize.html" title="struct leo_passes::AleoFinalize">Aleo<wbr>Finalize</a></dt><dt><a class="struct" href="struct.AleoFunction.html" title="struct leo_passes::AleoFunction">Aleo<wbr>Function</a></dt><dt><a class="struct" href="struct.AleoInput.html" title="struct leo_passes::AleoInput">Aleo<wbr>Input</a></dt><dt><a class="struct" href="struct.AleoMapping.html" title="struct leo_passes::AleoMapping">Aleo<wbr>Mapping</a></dt><dt><a class="struct" href="struct.AleoProgram.html" title="struct leo_passes::AleoProgram">Aleo<wbr>Program</a></dt><dt><a class="struct" href="struct.AleoRecord.html" title="struct leo_passes::AleoRecord">Aleo<wbr>Record</a></dt><dt><a class="struct" href="struct.AleoStruct.html" title="struct leo_passes::AleoStruct">Aleo<wbr>Struct</a></dt><dt><a class="struct" href="struct.Assigner.html" title="struct leo_passes::Assigner">Assigner</a></dt><dd>A struct used to create assignment statements.</dd><dt><a class="struct" href="struct.AssignerInner.html" title="struct leo_passes::AssignerInner">Assigner<wbr>Inner</a></dt><dd>Contains the actual data for <code>Assigner</code>.
Modeled this way to afford an API using interior mutability.</dd><dt><a class="struct" href="struct.CodeGenerating.html" title="struct leo_passes::CodeGenerating">Code<wbr>Generating</a></dt><dt><a class="struct" href="struct.CommonSubexpressionEliminating.html" title="struct leo_passes::CommonSubexpressionEliminating">Common<wbr>Subexpression<wbr>Eliminating</a></dt><dt><a class="struct" href="struct.CompilerState.html" title="struct leo_passes::CompilerState">Compiler<wbr>State</a></dt><dd>Contains data shared by many compiler passes.</dd><dt><a class="struct" href="struct.ConstPropUnrollAndMorphing.html" title="struct leo_passes::ConstPropUnrollAndMorphing">Const<wbr>Prop<wbr>Unroll<wbr>AndMorphing</a></dt><dd>Pass that runs const propagation, loop unrolling, and monomorphization until a fixed point.</dd><dt><a class="struct" href="struct.ConstPropagation.html" title="struct leo_passes::ConstPropagation">Const<wbr>Propagation</a></dt><dd>A pass to perform const propagation and folding.</dd><dt><a class="struct" href="struct.ConstPropagationOutput.html" title="struct leo_passes::ConstPropagationOutput">Const<wbr>Propagation<wbr>Output</a></dt><dt><a class="struct" href="struct.ConstPropagationVisitor.html" title="struct leo_passes::ConstPropagationVisitor">Const<wbr>Propagation<wbr>Visitor</a></dt><dt><a class="struct" href="struct.DeadCodeEliminating.html" title="struct leo_passes::DeadCodeEliminating">Dead<wbr>Code<wbr>Eliminating</a></dt><dt><a class="struct" href="struct.DeadCodeEliminatingOutput.html" title="struct leo_passes::DeadCodeEliminatingOutput">Dead<wbr>Code<wbr>Eliminating<wbr>Output</a></dt><dt><a class="struct" href="struct.Destructuring.html" title="struct leo_passes::Destructuring">Destructuring</a></dt><dd>A pass to rewrite tuple creation and accesses into other code.</dd><dt><a class="struct" href="struct.Finalizer.html" title="struct leo_passes::Finalizer">Finalizer</a></dt><dt><a class="struct" href="struct.Flattening.html" title="struct leo_passes::Flattening">Flattening</a></dt><dt><a class="struct" href="struct.FunctionInlining.html" title="struct leo_passes::FunctionInlining">Function<wbr>Inlining</a></dt><dt><a class="struct" href="struct.FunctionSymbol.html" title="struct leo_passes::FunctionSymbol">Function<wbr>Symbol</a></dt><dt><a class="struct" href="struct.Monomorphization.html" title="struct leo_passes::Monomorphization">Monomorphization</a></dt><dt><a class="struct" href="struct.MonomorphizationOutput.html" title="struct leo_passes::MonomorphizationOutput">Monomorphization<wbr>Output</a></dt><dt><a class="struct" href="struct.NameValidation.html" title="struct leo_passes::NameValidation">Name<wbr>Validation</a></dt><dd>A pass to validate names.</dd><dt><a class="struct" href="struct.OptionLowering.html" title="struct leo_passes::OptionLowering">Option<wbr>Lowering</a></dt><dt><a class="struct" href="struct.PathResolution.html" title="struct leo_passes::PathResolution">Path<wbr>Resolution</a></dt><dt><a class="struct" href="struct.ProcessingAsync.html" title="struct leo_passes::ProcessingAsync">Processing<wbr>Async</a></dt><dt><a class="struct" href="struct.ProcessingScript.html" title="struct leo_passes::ProcessingScript">Processing<wbr>Script</a></dt><dd>A pass to validate (and remove) uses of <code>interpret</code>.</dd><dt><a class="struct" href="struct.RemoveUnreachable.html" title="struct leo_passes::RemoveUnreachable">Remove<wbr>Unreachable</a></dt><dd>Pass that removes unreachable code created by early returns</dd><dt><a class="struct" href="struct.RemoveUnreachableOutput.html" title="struct leo_passes::RemoveUnreachableOutput">Remove<wbr>Unreachable<wbr>Output</a></dt><dt><a class="struct" href="struct.RemoveUnreachableVisitor.html" title="struct leo_passes::RemoveUnreachableVisitor">Remove<wbr>Unreachable<wbr>Visitor</a></dt><dt><a class="struct" href="struct.RenameTable.html" title="struct leo_passes::RenameTable">Rename<wbr>Table</a></dt><dd><code>RenameTable</code> tracks the names assigned by static single assignment in a single scope.</dd><dt><a class="struct" href="struct.Replacer.html" title="struct leo_passes::Replacer">Replacer</a></dt><dd>A <code>Replacer</code> traverses and reconstructs the AST, applying a user-defined replacement function to each <code>Expression</code>.</dd><dt><a class="struct" href="struct.SsaConstPropagation.html" title="struct leo_passes::SsaConstPropagation">SsaConst<wbr>Propagation</a></dt><dt><a class="struct" href="struct.SsaConstPropagationVisitor.html" title="struct leo_passes::SsaConstPropagationVisitor">SsaConst<wbr>Propagation<wbr>Visitor</a></dt><dd>Visitor that propagates constant values through the program.</dd><dt><a class="struct" href="struct.SsaForming.html" title="struct leo_passes::SsaForming">SsaForming</a></dt><dt><a class="struct" href="struct.SsaFormingInput.html" title="struct leo_passes::SsaFormingInput">SsaForming<wbr>Input</a></dt><dt><a class="struct" href="struct.StaticAnalyzing.html" title="struct leo_passes::StaticAnalyzing">Static<wbr>Analyzing</a></dt><dt><a class="struct" href="struct.StorageLowering.html" title="struct leo_passes::StorageLowering">Storage<wbr>Lowering</a></dt><dt><a class="struct" href="struct.SymbolTable.html" title="struct leo_passes::SymbolTable">Symbol<wbr>Table</a></dt><dd>Maps global and local symbols to information about them.</dd><dt><a class="struct" href="struct.SymbolTableCreation.html" title="struct leo_passes::SymbolTableCreation">Symbol<wbr>Table<wbr>Creation</a></dt><dd>A pass to fill the SymbolTable.</dd><dt><a class="struct" href="struct.TypeChecking.html" title="struct leo_passes::TypeChecking">Type<wbr>Checking</a></dt><dd>A pass to check types.</dd><dt><a class="struct" href="struct.TypeCheckingInput.html" title="struct leo_passes::TypeCheckingInput">Type<wbr>Checking<wbr>Input</a></dt><dd>Specify network limits for type checking.</dd><dt><a class="struct" href="struct.TypeTable.html" title="struct leo_passes::TypeTable">Type<wbr>Table</a></dt><dd>A mapping between node IDs and their types.</dd><dt><a class="struct" href="struct.Unrolling.html" title="struct leo_passes::Unrolling">Unrolling</a></dt><dt><a class="struct" href="struct.UnrollingOutput.html" title="struct leo_passes::UnrollingOutput">Unrolling<wbr>Output</a></dt><dt><a class="struct" href="struct.VariableSymbol.html" title="struct leo_passes::VariableSymbol">Variable<wbr>Symbol</a></dt><dd>An entry for a variable in the symbol table.</dd><dt><a class="struct" href="struct.WriteTransforming.html" title="struct leo_passes::WriteTransforming">Write<wbr>Transforming</a></dt><dd>A pass to rewrite assignments to array accesses and struct accesses.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.AleoDatatype.html" title="enum leo_passes::AleoDatatype">Aleo<wbr>Datatype</a></dt><dt><a class="enum" href="enum.AleoExpr.html" title="enum leo_passes::AleoExpr">Aleo<wbr>Expr</a></dt><dt><a class="enum" href="enum.AleoFunctional.html" title="enum leo_passes::AleoFunctional">Aleo<wbr>Functional</a></dt><dt><a class="enum" href="enum.AleoReg.html" title="enum leo_passes::AleoReg">AleoReg</a></dt><dt><a class="enum" href="enum.AleoStmt.html" title="enum leo_passes::AleoStmt">Aleo<wbr>Stmt</a></dt><dt><a class="enum" href="enum.AleoType.html" title="enum leo_passes::AleoType">Aleo<wbr>Type</a></dt><dt><a class="enum" href="enum.AleoVisibility.html" title="enum leo_passes::AleoVisibility">Aleo<wbr>Visibility</a></dt><dt><a class="enum" href="enum.VariableType.html" title="enum leo_passes::VariableType">Variable<wbr>Type</a></dt><dd>An enumeration of the different types of variable type.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.Pass.html" title="trait leo_passes::Pass">Pass</a></dt><dd>A compiler pass.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.make_optional_struct_symbol.html" title="fn leo_passes::make_optional_struct_symbol">make_<wbr>optional_<wbr>struct_<wbr>symbol</a></dt></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="type" href="type.ConditionalTreeNode.html" title="type leo_passes::ConditionalTreeNode">Conditional<wbr>Tree<wbr>Node</a></dt><dd>A binary search tree to store all paths through nested conditional blocks.</dd></dl></section></div></main></body></html>