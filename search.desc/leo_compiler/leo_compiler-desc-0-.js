searchState.loadedDescShard("leo_compiler", 0, "leo-compiler\nThe abstract syntax tree (AST) for a Leo program.\nThe primary entry point of the Leo compiler.\nReturns a reference to the inner program AST …\nThe <code>Assigner</code> is used to construct (unique) assignment …\nThe AST for the program.\nWhether spans are enabled in the output ASTs.\nBuild options.\nThe compiler for Leo programs.\nOptions configuring compilation.\nMax depth to type check nested conditionals.\nIf enabled writes the AST after dead code elimination.\nWhether to enable dead code elimination.\nIf enabled writes the AST after destructuring.\nWhether to disable type checking for nested conditionals.\nIf enabled writes the AST after flattening.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDeserializes the JSON string into a ast from a file.\nDeserializes the JSON string into a ast.\nThe handler is used for error and warning emissions.\nThe stubs for imported programs. Produced by <code>Retriever</code> …\nIf enabled writes the AST after parsing.\nIf enabled writes the AST after inlining.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe path to the main leo file.\nThe network name,\nCreates a new AST from a given program tree.\nThe <code>NodeCounter</code> used to generate sequentially increasing …\nOutput options.\nThe path to where the compiler outputs all generated files.\nThe program name,\nIf enabled writes the AST after static single assignment.\nSerializes the ast into a JSON file.\nSerializes the ast into a JSON value and removes keys from …\nSerializes the ast into a JSON string.\nThe type table.\nIf enabled writes the AST after loop unrolling.\nThe abstract syntax tree (AST) for a Leo program.\nThe primary entry point of the Leo compiler.\nMerges the dependencies defined in <code>program.json</code> with the …\nThe <code>Assigner</code> is used to construct (unique) assignment …\nThe AST for the program.\nReturns a SHA256 checksum of the program file.\nRuns the code generation pass.\nReturns a compiled Leo program.\nOptions configuring compilation.\nRuns the compiler stages.\nRun const propagation and loop unrolling until we hit a …\nRuns the const propagation pass.\nRuns the dead code elimination pass.\nRuns the destructuring pass.\nRuns the flattening pass.\nRuns the function inlining pass.\nThe handler is used for error and warning emissions.\nThe stubs for imported programs. Produced by <code>Retriever</code> …\nRuns the loop unrolling pass.\nThe path to the main leo file.\nThe network name,\nReturns a new Leo compiler.\nThe <code>NodeCounter</code> used to generate sequentially increasing …\nThe path to where the compiler outputs all generated files.\nParses and stores the main program file, constructs a …\nParses and stores a program file content from a string, …\nThe program name,\nRuns the static analysis pass.\nRuns the static single assignment pass.\nRuns the symbol table pass.\nRuns the type checker pass.\nThe type table.\nWrites the AST to a JSON file.\nWhether spans are enabled in the output ASTs.\nBuild options.\nMax depth to type check nested conditionals.\nIf enabled writes the AST after dead code elimination.\nWhether to enable dead code elimination.\nIf enabled writes the AST after destructuring.\nWhether to disable type checking for nested conditionals.\nIf enabled writes the AST after flattening.\nIf enabled writes the AST after parsing.\nIf enabled writes the AST after inlining.\nOutput options.\nIf enabled writes the AST after static single assignment.\nIf enabled writes the AST after loop unrolling.")