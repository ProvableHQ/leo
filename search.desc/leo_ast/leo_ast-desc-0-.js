searchState.loadedDescShard("leo_ast", 0, "The abstract syntax tree (ast) for a Leo program.\nAbsolute value checking for overflow, i.e. <code>.abs()</code>.\nAbsolute value wrapping around at the boundary of the …\nAddition, i.e. <code>+</code>, <code>.add()</code>.\nWrapping addition, i.e. <code>.add_wrapped()</code>.\nAn address literal, e.g., …\nThe <code>address</code> type.\nLogical AND, i.e. <code>&amp;&amp;</code>.\nAn annotation, e.g. @program.\nAn array expression, e.g., <code>[true, false, true, false]</code>.\nThe array type.\nAn array access expression, e.g., <code>foo[index]</code>.\nAn array access, e.g. <code>arr[i]</code>.\nAn array expression, e.g., <code>[true, false, true, false]</code>.\nAn array type.\nA <code>assert(expr)</code> variant, asserting that the expression …\nAn assert statement.\nA <code>assert_eq(expr1, expr2)</code> variant, asserting that the …\nA <code>assert_neq(expr1, expr2)</code> variant, asserting that the …\nAn assert statement, <code>assert(&lt;expr&gt;)</code>, <code>assert_eq(&lt;expr&gt;)</code> or …\nA variant of an assert statement.\nAn assignment statement.\nAn assignment statement, <code>assignee = value</code>. Note that there …\nAn associated constant; e.g., <code>group::GEN</code>.\nAn access expression to a struct constant., e.g. <code>u8::MAX</code>.\nAn associated function; e.g., <code>BHP256::hash_to_field</code>.\nAn access expression to an associated function in a …\nThe abstract syntax tree (AST) for a Leo program.\nA Reconstructor trait for types in the AST.\nA Visitor trait for types in the AST.\nAn <code>async</code> block: e.g. <code>async { my_mapping.set(1, 2); }</code>.\nAn <code>async</code> block: e.g. <code>async { my_mapping.set(1, 2); }</code>.\nA binary expression, e.g., <code>42 + 24</code>.\nA binary expression <code>left op right</code> of two operands …\nA binary operator.\nBitwise AND, i.e. <code>&amp;</code>, <code>.and()</code>.\nBitwise OR, i.e. <code>|</code>, <code>.or()</code>.\nA block <code>{ [stmt]* }</code> consisting of a list of statements to …\nA block statement.\nA boolean literal, either <code>true</code> or <code>false</code>.\nThe <code>bool</code> type.\nA call expression, e.g., <code>my_fun(args)</code>.\nA function call expression, e.g.<code>foo(args)</code> or <code>Foo::bar(args)</code>…\nA cast expression, e.g., <code>42u32 as u8</code>.\nA cast expression, e.g. <code>42u8 as u16</code>.\nA composite type definition, e.g., …\nThe <code>struct</code> type.\nA composite type of a identifier and external program name.\nAn <code>if</code> statement.\nAn <code>if condition block (else next)?</code> statement.\nA binding from identifier to constant value.\nA constant declaration statement.\nA Consumer trait for constructors in the AST.\nA core constant that maps directly to an AVM bytecode …\nA core instruction that maps directly to an AVM bytecode …\nA binding or set of bindings / variables to declare.\nA <code>let</code> or <code>const</code> declaration statement.\nDivision, i.e. <code>/</code>, <code>.div()</code>.\nWrapping division, i.e. <code>.div_wrapped()</code>.\nDouble operation, i.e. <code>.double()</code>.\nEquality relation, i.e. <code>==</code>, <code>.eq()</code>.\nAn expression of type “error”. Will result in a …\nPlaceholder for a type that could not be resolved or was …\nRepresents a syntactically invalid expression.\nExpression that evaluates to a value.\nAn expression statement\nA Consumer trait for expressions in the AST.\nAn expression statement, <code>foo(a);</code>.\nA field literal, e.g., <code>42field</code>. A signed number followed …\nThe <code>field</code> type.\nThis trait allows to parse integer literals of any type …\nA function definition.\nA Consumer trait for functions in the AST.\nA function stub definition.\nThe <code>future</code> type.\nA future type consisting of the type of the inputs.\nA group literal, eg <code>42group</code>.\nThe <code>group</code> type.\nGreater-than relation, i.e. <code>&gt;</code>, <code>.gt()</code>.\nGreater-or-equal relation, i.e. <code>&gt;=</code>, <code>.gte()</code>.\nA reference to a built in type.\nA Consumer trait for imported programs in the AST.\nA function parameter.\nAn integer literal, e.g., <code>42u32</code>.\nAn integer type.\nExplicit integer type.\nMultiplicative inverse, i.e. <code>.inv()</code>.\nA <code>for</code> statement.\nA bounded <code>for</code> loop statement …\nA literal.\nA literal expression.\nA locator expression, e.g., <code>hello.aleo/foo</code>.\nA locator that references an external resource.\nLesser-than relation, i.e. <code>&lt;</code>, <code>.lt()</code>.\nLesser-or-equal relation, i.e. <code>&lt;=</code>, <code>.lte()</code>.\nA mapping declaration, e.g …\nA mapping type.\nA Consumer trait for mappings in the AST.\nA mapping type of a key and value type.\nA member of a structured data type, e.g <code>foobar: u8</code> or …\nA struct member access expression <code>inner.name</code> to some …\nAn access of a struct member, e.g. <code>struc.member</code>.\nArithmetic modulo, i.e. <code>.mod()</code>\nThe mode associated with a type.\nStores the abstract syntax tree of a Leo module.\nA Consumer trait for modules in the AST.\nMultiplication, i.e. <code>*</code>, <code>.mul()</code>.\nWrapping multiplication, i.e. <code>.mul_wrapped()</code>.\nBoolean NAND, i.e. <code>.nand()</code>.\nNegate operation, i.e. <code>.neg()</code>.\nIn-equality relation, i.e. <code>!=</code>, <code>.neq()</code>.\nBoolean NOR, i.e. <code>.nor()</code>.\nBitwise NOT, i.e. <code>!</code>, <code>.not()</code>.\nNumeric type which should be resolved to <code>Field</code>, <code>Group</code>, …\nLogical OR, i.e. <code>||</code>.\nA function output.\nA path to some item, e.g., <code>foo::bar::x</code>.\nExponentiation, i.e. <code>**</code> in <code>a ** b</code>, <code>.pow()</code>.\nWrapping exponentiation, i.e. <code>.pow_wrapped()</code>.\nStores the Leo program abstract syntax tree.\nA Consumer trait for the program represented by the AST.\nAn identifier for a program that is eventually deployed to …\nA Reconstructor trait for the program represented by the …\nStores the Leo program scope abstract syntax tree.\nA Consumer trait for program scopes in the AST.\nA Visitor trait for the program represented by the AST.\nRemainder, i.e. <code>%</code>, <code>.rem()</code>.\nWrapping remainder, i.e. <code>.rem_wrapped()</code>.\nAn array expression constructed from one repeated element, …\nAn array expression constructed from one repeated element.\nA return statement <code>return expr;</code>.\nA return statement <code>return expression;</code>.\nA scalar literal, e.g. <code>1scalar</code>. An unsigned number …\nThe <code>scalar</code> type.\n<code>script</code> can only appear in test files, and is used for …\nShift left operation, i.e. <code>&lt;&lt;</code>, <code>.shl()</code>.\nWrapping shift left operation, i.e. <code>.shl_wrapped()</code>.\nShift right operation, i.e. &gt;&gt;, <code>.shr()</code>.\nWrapping shift right operation, i.e. <code>.shr_wrapped()</code>.\nThe <code>signature</code> type.\nSquare operation, i.e. <code>.square()</code>.\nSquare root operation, i.e. <code>.sqrt()</code>.\nProgram statement that defines some action (or expression) …\nA Consumer trait for statements in the AST.\nA string literal, e.g., <code>&quot;foobar&quot;</code>.\nThe <code>string</code> type.\nAn expression constructing a struct like …\nA Consumer trait for structs in the AST.\nA struct initialization expression, e.g., …\nAn initializer for a single field / variable of a struct …\nStores the Leo stub abstract syntax tree.\nSubtraction, i.e. <code>-</code>, <code>.sub()</code>.\nWrapped subtraction, i.e. <code>.sub_wrapped()</code>.\nA ternary conditional expression <code>cond ? if_expr : else_expr</code>…\nA ternary conditional expression, that is, …\nConverts a group element to its x-coordinate, i.e. …\nConverts a group element to its y-coordinate, i.e. …\nA tuple expression e.g., <code>(foo, 42, true)</code>.\nA static tuple of at least one type.\nA tuple access expression, e.g., <code>tuple.index</code>.\nA tuple access expression e.g., <code>foo.2</code>.\nA tuple expression, e.g., <code>(foo, false, 42)</code>.\nA type list of at least two types.\nExplicit type used for defining a variable or expression …\nAn unary expression.\nAn unary expression applying an operator to an inner …\nA unary operator for a unary expression.\nA unit expression e.g. <code>()</code>\nThe <code>unit</code> type.\nRepresents a unit expression.\nAn unsuffixed literal, e.g. <code>42</code> (without a type suffix)\nFunctions are always one of six variants. A transition …\nBitwise XOR, i.e. <code>.xor()</code>.\nAnnotations on the function.\nAnnotations on the function.\nThe arguments passed to the function <code>name</code>.\nExpressions for the arguments passed to the function’s …\nAn expression evaluating to some array type, e.g., …\nReturns a reference to the inner program AST …\nThe block to run asynchronously.\nThe body of the function.\nThe block to run on each iteration.\nThe condition determining which branch to pick.\nThe <code>bool</code>-typed condition deciding what to evaluate.\nExpressions for the const arguments passed to the function…\nExpressions for the const arguments passed to the struct’…\nExpressions for the const arguments passed to the struct’…\nThe composite’s const parameters.\nThe function’s const parameters.\nAn optional constructor.\nA vector of const definitions.\nA vector of const definitions.\nA vector of const definitions.\nThe number of times to repeat it.\nConstructs an empty program node.\nConstructs an empty program stub\nThe elements of the array.\nThe elements of the tuple. In the example above, it would …\nThe element to repeat.\nThe expression to be casted, e.g.<code>42u8</code> in <code>42u8 as u16</code>.\nThe expression to initialize the field with. When <code>None</code>, a …\nThe expression associated with the statement.\nThe expression to return to the function caller.\nThe external program the struct is defined in.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDeserializes the JSON string into a ast from a file.\nDeserializes the JSON string into a ast.\nA path to a callable function, either a member of a …\nA vector of function definitions.\nA vector of function definitions.\nA vector of function stub definitions.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the expression.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe identifier of the member.\nThe name of the type in the type system in this module.\nThe name of the field / variable to be initialized.\nThe name of the annotation.\nThe name the parameter is accessible as in the function’…\nThe function identifier, e.g., <code>foo</code> in …\nThe name of the mapping.\nThe function identifier, e.g., <code>foo</code> in …\nThe branch the expression evaluates to if <code>condition</code> …\nThe branch the expression evaluates to if <code>condition</code> …\nA map from import names to import definitions.\nA vector of imported programs.\nWhether <code>stop</code> is inclusive or not. Signified with <code>=</code> when …\nThe index to access in the array expression. E.g., <code>0</code> for …\nThe index to access in the tuple expression. E.g., <code>0</code> for …\nThe inner struct that is being accessed.\nThe function’s input parameters.\nThe function’s input parameters.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWas this a <code>record Foo { ... }</code>? If so, it wasn’t a …\nThe type of the key.\nThe left operand of the expression.\nKeys and value associated with the annotation.\nA vector of mapping definitions.\nA vector of mapping definitions.\nThe fields, constant variables, and functions of this …\nInitializer expressions for each of the fields in the …\nThe mode of the member.\nThe mode of the function parameter.\nThe mode of the function output.\nA Leo module represents a collection of declarations …\nA map from module paths to module definitions.\nThe struct constant that is being accessed.\nThe static struct member function that is being accessed.\nThe name of the struct member to access.\nThe name of the resource.\nThe name of the program.\nThe network associated with the program.\nCreates a new AST from a given program tree.\nHelper function to normalize AST JSON into a form …\nThe operand defining the meaning of the resulting binary …\nThe unary operator to apply to <code>inner</code>.\nThe statement, if any, to evaluate when <code>condition</code> yields …\nThe function’s output declarations.\nThe function’s output declarations.\nThe function’s output type.\nThe function’s output type.\nThis module contains both a Reducer and Visitor design …\nA path to a structure type to initialize.\nThe path to the module.\nThe path to the composite definition.\nThe place to assign to.\nThe place to assign to. As opposed to <code>DefinitionStatement</code>, …\nThe bindings / variable names to declare.\nA Leo program consists of import statements and program …\nThe name of the parent program call, e.g.<code>bar</code> in <code>bar.aleo</code>.\nThe program that the resource is in.\nThe external program that this composite is defined in.\nThe program id of the program scope.\nThe name of the program that this module belongs to.\nA map from program names to program scopes.\nThe inner expression <code>op</code> is applied to.\nHelper function to recursively filter keys from AST JSON\nThe right operand of the expression.\nThe span of the member.\nThe entire span of the composite definition.\nThe span for the entire expression <code>foo[index]</code>.\nThe span for the entire expression <code>Foo::bar()</code>.\nThe span for the entire expression <code>Foo::bar()</code>.\nThe span for the entire expression …\nThe span from <code>[</code> to <code>]</code>.\nThe span from <code>left</code> to <code>right</code>.\nSpan of the entire call <code>function(arguments)</code>.\nSpan of the entire cast <code>42u8 as u16</code>.\nThe span of the invalid expression.\nThe span covering all of <code>inner.name</code>.\nThe span from <code>[</code> to <code>]</code>.\nThe span of the node.\nA span from <code>name</code> to <code>}</code>.\nThe span from <code>condition</code> to <code>if_false</code>.\nThe span from <code>(</code> to <code>)</code>.\nThe span for the entire expression <code>tuple.index</code>.\nThe span covering <code>op inner</code>.\nThe span of the unit expression.\nA span indicating where the locator occurred in the source.\nA span locating where the annotation occurred in the …\nThe parameters span from any annotations to its type.\nThe parameters span from any annotations to its type.\nThe entire span of the function definition.\nThe entire span of the mapping declaration.\nThe span associated with the program scope.\nThe span, excluding the semicolon.\nThe span, excluding the semicolon.\nThe span from <code>{</code> to <code>}</code>.\nThe span from <code>if</code> to <code>next</code> or to <code>block</code>.\nThe span excluding the semicolon.\nThe span excluding the semicolon.\nThe span.\nThe span from <code>for</code> to <code>block</code>.\nThe span of <code>return expression</code> excluding the semicolon.\nThe entire span of the function definition.\nThe span associated with the stub.\nThe start of the iteration.\nThe list of statements to execute.\nThe end of the iteration, possibly <code>inclusive</code>.\nA vector of struct definitions.\nA vector of struct definitions.\nA vector of struct definitions.\nA stub contains function templates as well as definitions …\nThe stub id\nA map from program stub names to program stub scopes.\nThe block to evaluate in case <code>condition</code> yields <code>true</code>.\nSerializes the ast into a JSON file.\nSerializes the ast into a JSON value and removes keys from …\nSerializes the ast into a JSON string.\nConverts a literal to a value.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\nAn expression evaluating to some tuple type, e.g., <code>(5, 2)</code>.\nThe inner struct type.\nThe type of the member.\nThe type to be casted to, e.g. <code>u16</code> in <code>42u8 as u16</code>.\nWhat’s the parameter’s type?\nThe type of the function output.\nThe type of the binding, if specified, or inferred …\nThe types of the bindings, if specified, or inferred …\nThe type of the iteration.\nThe value to assign to the <code>assignee</code>.\nAn initializer value for the binding.\nAn initializer value for the bindings.\nThe type of the value.\nThe binding / variable to introduce in the body <code>block</code>.\nThe inner struct variant.\nIs this function a transition, inlined, or a regular …\nThe variant of the assert statement.\nIs this function a transition, inlined, or a regular …\nA call graph.\nA const parameter for a function or a composite.\nAn error that is emitted when a cycle is detected in the …\nA directed graph using reference-counted nodes.\nErrors in directed graph operations.\nA node in a graph.\nAn identifier in a program.\nAn import dependency graph.\nA counter that produces sequentially increasing <code>NodeID</code>s.\nContains the actual data for <code>Handler</code>. Modeled this way to …\nA number string guaranteed to be non-negative.\nA Path in a program.\nA struct dependency graph. The <code>Vec&lt;Symbol&gt;</code> is to the …\nThe fully resolved path. We may not know this until the …\nThe directed edges in the graph. Each entry in the map is …\nThe directed edges in the graph. Each entry in the map is …\nThe directed edges in the graph. Each entry in the map is …\nThe directed edges in the graph. Each entry in the map is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe name of the const parameter.\nThe final item in the path, e.g., <code>baz</code> in <code>foo::bar::baz</code>.\nThe inner counter. <code>RefCell</code> is used here to avoid <code>&amp;mut</code> all …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe symbol that the user wrote, e.g., <code>foo</code>.\nThe next <code>NodeID</code>.\nThe set of nodes in the graph.\nThe set of nodes in the graph.\nThe set of nodes in the graph.\nThe set of nodes in the graph.\nThe absolute path to the item that this <code>Location</code> points to.\nThe program name. e.g. <code>credits</code>. Note. This does not …\nThe qualifying namespace segments written by the user, …\nThe const parameter’s span from any annotations to its …\nA span locating where the identifier occurred in the …\nA span locating where the path occurred in the source.\nThe string representation of the non-negative number.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\nWhat’s the const parameter’s type?\nThe numeric value of the non-negative number.\nA const parameter for a function or a composite.\nThe ID of the node.\nThe name of the const parameter.\nThe const parameter’s span from any annotations to its …\nWhat’s the const parameter’s type?\nA call graph.\nAn error that is emitted when a cycle is detected in the …\nA directed graph using reference-counted nodes.\nErrors in directed graph operations.\nA node in a graph.\nAn import dependency graph.\nA struct dependency graph. The <code>Vec&lt;Symbol&gt;</code> is to the …\nAdds an edge to the graph.\nAdds a node to the graph.\nReturns <code>true</code> if the graph contains the given node.\nThe directed edges in the graph. Each entry in the map is …\nThe directed edges in the graph. Each entry in the map is …\nThe directed edges in the graph. Each entry in the map is …\nThe directed edges in the graph. Each entry in the map is …\nHelper: get or insert Rc into the graph.\nReturns an iterator to the immediate neighbors of a given …\nInitializes a new <code>DiGraph</code> from a set of source nodes.\nReturns an iterator over the nodes in the graph.\nThe set of nodes in the graph.\nThe set of nodes in the graph.\nThe set of nodes in the graph.\nThe set of nodes in the graph.\nReturns the post-order ordering of the graph. Detects if …\nReturns the post-order ordering of the graph but only …\nRemoves a node and all associated edges from the graph.\nRetains a subset of the nodes, and removes all edges in …\nAn identifier in a program.\nThe ID of the node.\nCheck if the Identifier name matches the other name.\nThe symbol that the user wrote, e.g., <code>foo</code>.\nConstructs a new identifier with <code>name</code> and <code>id</code> and a default …\nA span locating where the identifier occurred in the …\nThe absolute path to the item that this <code>Location</code> points to.\nThe program name. e.g. <code>credits</code>. Note. This does not …\nA node in the AST.\nA node ID.\nReturns the ID of the node.\nSets the ID of the node.\nSets the span of the node.\nReturns the span of the node.\nA counter that produces sequentially increasing <code>NodeID</code>s.\nContains the actual data for <code>Handler</code>. Modeled this way to …\nThe inner counter. <code>RefCell</code> is used here to avoid <code>&amp;mut</code> all …\nReturns a new <code>NodeCounter</code> with the given <code>NodeID</code> as the …\nReturns a new <code>NodeCounter</code> with the given <code>NodeID</code> as the …\nThe next <code>NodeID</code>.\nReturns the next <code>NodeID</code> and increments the internal state.\nReturns the next <code>NodeID</code> and increments the internal state.\nA Path in a program.\nReturns a slice of <code>Symbol</code>s representing the resolved …\nThe fully resolved path. We may not know this until the …\nReturns a <code>Vec&lt;Symbol&gt;</code> representing the full symbolic path: …\nThe ID of the node.\nThe final item in the path, e.g., <code>baz</code> in <code>foo::bar::baz</code>.\nThe qualifying namespace segments written by the user, …\nA span locating where the path occurred in the source.\nReturns an optional slice of <code>Symbol</code>s representing the …\nSets <code>self.absolute_path</code> to <code>absolute_path</code>\nSets the <code>absolute_path</code> by prepending the given …\nReturns a new <code>Path</code> instance with the last segment’s …\nA number string guaranteed to be non-negative.\nReturns <code>true</code> if this number is zero.\nReturns the string representation of the non-negative …\nThe string representation of the non-negative number.\nReturns the numeric value of the non-negative number.\nThe numeric value of the non-negative number.\nA constructor definition.\nThe upgrade variant.\nAnnotations on the constructor.\nThe body of the constructor.\nReturns the argument unchanged.\nReturns the argument unchanged.\nChecks that the constructor’s annotations are valid and …\nThe ID of the node.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis is the expected snarkVM constructor bytecode for a …\nThis is the required snarkVM constructor bytecode for a …\nThis is the expected snarkVM constructor bytecode for a …\nThe entire span of the constructor definition.\n<code>ToString::to_string</code>, but without panic on OOM.\nThis is the expected snarkVM constructor bytecode for a …\nThis is the required snarkVM constructor bytecode for a …\nThis is the expected snarkVM constructor bytecode for a …\nAn array expression, e.g., <code>[true, false, true, false]</code>.\nAn array access, e.g. <code>arr[i]</code>.\nAn associated constant; e.g., <code>group::GEN</code>.\nAn associated function; e.g., <code>BHP256::hash_to_field</code>.\nAn <code>async</code> block: e.g. <code>async { my_mapping.set(1, 2); }</code>.\nA binary expression, e.g., <code>42 + 24</code>.\nA call expression, e.g., <code>my_fun(args)</code>.\nA cast expression, e.g., <code>42u32 as u8</code>.\nAn expression of type “error”. Will result in a …\nExpression that evaluates to a value.\nA literal expression.\nA locator expression, e.g., <code>hello.aleo/foo</code>.\nAn access of a struct member, e.g. <code>struc.member</code>.\nA path to some item, e.g., <code>foo::bar::x</code>.\nAn array expression constructed from one repeated element, …\nAn expression constructing a struct like …\nA ternary conditional expression <code>cond ? if_expr : else_expr</code>…\nA tuple expression e.g., <code>(foo, 42, true)</code>.\nA tuple access expression e.g., <code>foo.2</code>.\nAn unary expression.\nA unit expression e.g. <code>()</code>\nReturns <code>self</code> as a known <code>u32</code> if possible. Otherwise, …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAn array expression, e.g., <code>[true, false, true, false]</code>.\nThe elements of the array.\nThe ID of the node.\nThe span from <code>[</code> to <code>]</code>.\nAn array access expression, e.g., <code>foo[index]</code>.\nAn expression evaluating to some array type, e.g., …\nThe ID of the node.\nThe index to access in the array expression. E.g., <code>0</code> for …\nThe span for the entire expression <code>foo[index]</code>.\nAn access expression to a struct constant., e.g. <code>u8::MAX</code>.\nThe ID of the node.\nThe struct constant that is being accessed.\nThe span for the entire expression <code>Foo::bar()</code>.\nThe inner struct type.\nAn access expression to an associated function in a …\nThe arguments passed to the function <code>name</code>.\nThe ID of the node.\nThe static struct member function that is being accessed.\nThe span for the entire expression <code>Foo::bar()</code>.\nThe inner struct variant.\nAn <code>async</code> block: e.g. <code>async { my_mapping.set(1, 2); }</code>.\nThe block to run asynchronously.\nThe ID of the node.\nThe span for the entire expression …\nAddition, i.e. <code>+</code>, <code>.add()</code>.\nWrapping addition, i.e. <code>.add_wrapped()</code>.\nLogical AND, i.e. <code>&amp;&amp;</code>.\nA binary expression <code>left op right</code> of two operands …\nA binary operator.\nBitwise AND, i.e. <code>&amp;</code>, <code>.and()</code>.\nBitwise OR, i.e. <code>|</code>, <code>.or()</code>.\nDivision, i.e. <code>/</code>, <code>.div()</code>.\nWrapping division, i.e. <code>.div_wrapped()</code>.\nEquality relation, i.e. <code>==</code>, <code>.eq()</code>.\nGreater-than relation, i.e. <code>&gt;</code>, <code>.gt()</code>.\nGreater-or-equal relation, i.e. <code>&gt;=</code>, <code>.gte()</code>.\nLesser-than relation, i.e. <code>&lt;</code>, <code>.lt()</code>.\nLesser-or-equal relation, i.e. <code>&lt;=</code>, <code>.lte()</code>.\nArithmetic modulo, i.e. <code>.mod()</code>\nMultiplication, i.e. <code>*</code>, <code>.mul()</code>.\nWrapping multiplication, i.e. <code>.mul_wrapped()</code>.\nBoolean NAND, i.e. <code>.nand()</code>.\nIn-equality relation, i.e. <code>!=</code>, <code>.neq()</code>.\nBoolean NOR, i.e. <code>.nor()</code>.\nLogical OR, i.e. <code>||</code>.\nExponentiation, i.e. <code>**</code> in <code>a ** b</code>, <code>.pow()</code>.\nWrapping exponentiation, i.e. <code>.pow_wrapped()</code>.\nRemainder, i.e. <code>%</code>, <code>.rem()</code>.\nWrapping remainder, i.e. <code>.rem_wrapped()</code>.\nShift left operation, i.e. <code>&lt;&lt;</code>, <code>.shl()</code>.\nWrapping shift left operation, i.e. <code>.shl_wrapped()</code>.\nShift right operation, i.e. &gt;&gt;, <code>.shr()</code>.\nWrapping shift right operation, i.e. <code>.shr_wrapped()</code>.\nSubtraction, i.e. <code>-</code>, <code>.sub()</code>.\nWrapped subtraction, i.e. <code>.sub_wrapped()</code>.\nBitwise XOR, i.e. <code>.xor()</code>.\nReturns a <code>BinaryOperation</code> from the given <code>Symbol</code>. This is …\nThe ID of the expression.\nThe left operand of the expression.\nThe operand defining the meaning of the resulting binary …\nThe right operand of the expression.\nThe span from <code>left</code> to <code>right</code>.\nA function call expression, e.g.<code>foo(args)</code> or <code>Foo::bar(args)</code>…\nExpressions for the arguments passed to the function’s …\nExpressions for the const arguments passed to the function…\nA path to a callable function, either a member of a …\nThe ID of the node.\nThe name of the parent program call, e.g.<code>bar</code> in <code>bar.aleo</code>.\nSpan of the entire call <code>function(arguments)</code>.\nA cast expression, e.g. <code>42u8 as u16</code>.\nThe expression to be casted, e.g.<code>42u8</code> in <code>42u8 as u16</code>.\nThe ID of the node.\nSpan of the entire cast <code>42u8 as u16</code>.\nThe type to be casted to, e.g. <code>u16</code> in <code>42u8 as u16</code>.\nRepresents a syntactically invalid expression.\nThe ID of the node.\nThe span of the invalid expression.\nAn address literal, e.g., …\nA boolean literal, either <code>true</code> or <code>false</code>.\nA field literal, e.g., <code>42field</code>. A signed number followed …\nThis trait allows to parse integer literals of any type …\nA group literal, eg <code>42group</code>.\nAn integer literal, e.g., <code>42u32</code>.\nA literal.\nA scalar literal, e.g. <code>1scalar</code>. An unsigned number …\nA string literal, e.g., <code>&quot;foobar&quot;</code>.\nAn unsuffixed literal, e.g. <code>42</code> (without a type suffix)\nFor an integer literal, parse it and cast it to a u32.\nFor displaying a literal as decimal, regardless of the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>ToString::to_string</code>, but without panic on OOM.\nA locator that references an external resource.\nThe ID of the node.\nCheck if the Locator name and program matches the other …\nThe name of the resource.\nConstructs a new Locator with <code>name</code>, <code>program</code> and <code>id</code> and a …\nThe program that the resource is in.\nA span indicating where the locator occurred in the source.\nA struct member access expression <code>inner.name</code> to some …\nThe ID of the node.\nThe inner struct that is being accessed.\nThe name of the struct member to access.\nThe span covering all of <code>inner.name</code>.\nAn array expression constructed from one repeated element.\nThe number of times to repeat it.\nThe element to repeat.\nThe ID of the node.\nThe span from <code>[</code> to <code>]</code>.\nA struct initialization expression, e.g., …\nAn initializer for a single field / variable of a struct …\nExpressions for the const arguments passed to the struct’…\nThe expression to initialize the field with. When <code>None</code>, a …\nThe ID of the node.\nThe ID of the node.\nThe name of the field / variable to be initialized.\nInitializer expressions for each of the fields in the …\nA path to a structure type to initialize.\nThe span of the node.\nA span from <code>name</code> to <code>}</code>.\nA ternary conditional expression, that is, …\nThe condition determining which branch to pick.\nThe ID of the node.\nThe branch the expression evaluates to if <code>condition</code> …\nThe branch the expression evaluates to if <code>condition</code> …\nThe span from <code>condition</code> to <code>if_false</code>.\nA tuple expression, e.g., <code>(foo, false, 42)</code>.\nThe elements of the tuple. In the example above, it would …\nThe ID of the node.\nThe span from <code>(</code> to <code>)</code>.\nA tuple access expression, e.g., <code>tuple.index</code>.\nThe ID of the node.\nThe index to access in the tuple expression. E.g., <code>0</code> for …\nThe span for the entire expression <code>tuple.index</code>.\nAn expression evaluating to some tuple type, e.g., <code>(5, 2)</code>.\nAbsolute value checking for overflow, i.e. <code>.abs()</code>.\nAbsolute value wrapping around at the boundary of the …\nDouble operation, i.e. <code>.double()</code>.\nMultiplicative inverse, i.e. <code>.inv()</code>.\nNegate operation, i.e. <code>.neg()</code>.\nBitwise NOT, i.e. <code>!</code>, <code>.not()</code>.\nSquare operation, i.e. <code>.square()</code>.\nSquare root operation, i.e. <code>.sqrt()</code>.\nConverts a group element to its x-coordinate, i.e. …\nConverts a group element to its y-coordinate, i.e. …\nAn unary expression applying an operator to an inner …\nA unary operator for a unary expression.\nRepresents the operator as a string.\nReturns a <code>UnaryOperation</code> from the given <code>Symbol</code>.\nThe ID of the node.\nThe unary operator to apply to <code>inner</code>.\nThe inner expression <code>op</code> is applied to.\nThe span covering <code>op inner</code>.\nRepresents a unit expression.\nThe ID of the node.\nThe span of the unit expression.\nA function stub definition.\nAnnotations on the function.\nThe ID of the node.\nThe function identifier, e.g., <code>foo</code> in …\nThe function’s input parameters.\nThe function’s output declarations.\nThe function’s output type.\nThe entire span of the function definition.\nIs this function a transition, inlined, or a regular …\nA function definition.\nAnnotations on the function.\nThe body of the function.\nThe function’s const parameters.\nThe ID of the node.\nThe function identifier, e.g., <code>foo</code> in …\nThe function’s input parameters.\nReturns function name.\nInitialize a new function.\nThe function’s output declarations.\nThe function’s output type.\nThe entire span of the function definition.\nIs this function a transition, inlined, or a regular …\nAn annotation, e.g. @program.\nThe ID of the node.\nThe name of the annotation.\nKeys and value associated with the annotation.\nA span locating where the annotation occurred in the …\nA core instruction that maps directly to an AVM bytecode …\nReturns a <code>CoreFunction</code> from the given module and method …\nReturns whether or not this function is finalize command.\nReturns the number of arguments required by the …\nA function parameter.\nThe ID of the node.\nThe name the parameter is accessible as in the function’…\nThe mode of the function parameter.\nThe parameters span from any annotations to its type.\nWhat’s the parameter’s type?\nThe mode associated with a type.\nA function output.\nThe ID of the node.\nThe mode of the function output.\nThe parameters span from any annotations to its type.\nThe type of the function output.\n<code>script</code> can only appear in test files, and is used for …\nFunctions are always one of six variants. A transition …\nReturns true if the variant is async.\nReturns true if the variant is an async function.\nReturns true if the variant is a function.\nIs this a <code>script</code>?\nReturns true if the variant is a transition.\nImplements <code>Display</code> by putting 4 spaces in front of each …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>ToString::to_string</code>, but without panic on OOM.\nA context in which we can evaluate core functions.\nGlobal values - such as mappings, functions, etc - are …\nA Leo value of any type.\nConvert to the given type if possible under Aleo casting …\nAre the values equal, according to SnarkVM?\nEvaluate a binary operation.\nEvaluate a unary operation.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn the group generator.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nResolves an unsuffixed literal to a typed <code>Value</code> using the …\nDoesn’t correspond to Aleo’s shl, because it does not …\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\nA context in which we can evaluate core functions.\nEvaluate a binary operation.\nEvaluate a unary operation.\nResolves unsuffixed numeric operands for binary operations …\nResolves an unsuffixed operand for a unary operation by …\nGlobal values - such as mappings, functions, etc - are …\nA Leo value of any type.\nGets the type of a <code>Value</code> but only if it is an integer, a …\nA locator that references an external resource.\nThe ID of the node.\nThe name of the resource.\nThe program that the resource is in.\nA span indicating where the locator occurred in the source.\nA mapping declaration, e.g …\nThe ID of the node.\nThe name of the mapping.\nThe type of the key.\nThe entire span of the mapping declaration.\nThe type of the value.\nA member of a structured data type, e.g <code>foobar: u8</code> or …\nThe ID of the node.\nThe identifier of the member.\nThe mode of the member.\nThe span of the member.\nThe type of the member.\nStores the abstract syntax tree of a Leo module.\nA vector of const definitions.\nA vector of function definitions.\nThe path to the module.\nThe name of the program that this module belongs to.\nA vector of struct definitions.\nThis module contains a Consumer trait for the AST. …\nThis module contains a Reconstructor trait for the AST. It …\nThis module contains Visitor trait implementations for the …\nA Consumer trait for constructors in the AST.\nA Consumer trait for expressions in the AST.\nA Consumer trait for functions in the AST.\nA Consumer trait for imported programs in the AST.\nA Consumer trait for mappings in the AST.\nA Consumer trait for modules in the AST.\nA Consumer trait for the program represented by the AST.\nA Consumer trait for program scopes in the AST.\nA Consumer trait for statements in the AST.\nA Consumer trait for structs in the AST.\nA Reconstructor trait for types in the AST.\nA Reconstructor trait for the program represented by the …\nA Visitor trait for types in the AST.\nA Visitor trait for the program represented by the AST.\nStores the Leo program abstract syntax tree.\nA map from import names to import definitions.\nA map from module paths to module definitions.\nA Leo program scope consists of struct, function, and …\nA map from program names to program scopes.\nA map from program stub names to program stub scopes.\nAn identifier for a program that is eventually deployed to …\nInitializes a new <code>ProgramId</code> from a string, using a network …\nThe name of the program.\nThe network associated with the program.\nConverts the <code>ProgramId</code> into an address string.\nStores the Leo program scope abstract syntax tree.\nAn optional constructor.\nA vector of const definitions.\nA vector of function definitions.\nA vector of mapping definitions.\nThe program id of the program scope.\nThe span associated with the program scope.\nA vector of struct definitions.\nAn assert statement.\nAn assignment statement.\nA block statement.\nAn <code>if</code> statement.\nA binding from identifier to constant value.\nA binding or set of bindings / variables to declare.\nAn expression statement\nA <code>for</code> statement.\nA return statement <code>return expr;</code>.\nProgram statement that defines some action (or expression) …\nReturns a dummy statement made from an empty block <code>{}</code>.\nA <code>assert(expr)</code> variant, asserting that the expression …\nA <code>assert_eq(expr1, expr2)</code> variant, asserting that the …\nA <code>assert_neq(expr1, expr2)</code> variant, asserting that the …\nAn assert statement, <code>assert(&lt;expr&gt;)</code>, <code>assert_eq(&lt;expr&gt;)</code> or …\nA variant of an assert statement.\nThe ID of the node.\nThe span, excluding the semicolon.\nThe variant of the assert statement.\nAn assignment statement, <code>assignee = value</code>. Note that there …\nThe ID of the node.\nThe place to assign to.\nThe span, excluding the semicolon.\nThe value to assign to the <code>assignee</code>.\nA block <code>{ [stmt]* }</code> consisting of a list of statements to …\nThe ID of the node.\nThe span from <code>{</code> to <code>}</code>.\nThe list of statements to execute.\nAn <code>if condition block (else next)?</code> statement.\nThe <code>bool</code>-typed condition deciding what to evaluate.\nThe ID of the node.\nThe statement, if any, to evaluate when <code>condition</code> yields …\nThe span from <code>if</code> to <code>next</code> or to <code>block</code>.\nThe block to evaluate in case <code>condition</code> yields <code>true</code>.\nA constant declaration statement.\nThe ID of the node.\nThe place to assign to. As opposed to <code>DefinitionStatement</code>, …\nThe span excluding the semicolon.\nThe type of the binding, if specified, or inferred …\nAn initializer value for the binding.\nA <code>let</code> or <code>const</code> declaration statement.\nThe ID of the node.\nThe bindings / variable names to declare.\nThe span excluding the semicolon.\nThe types of the bindings, if specified, or inferred …\nAn initializer value for the bindings.\nAn expression statement, <code>foo(a);</code>.\nThe expression associated with the statement.\nThe ID of the node.\nThe span.\nA bounded <code>for</code> loop statement …\nThe block to run on each iteration.\nThe ID of the node.\nWhether <code>stop</code> is inclusive or not. Signified with <code>=</code> when …\nThe span from <code>for</code> to <code>block</code>.\nThe start of the iteration.\nThe end of the iteration, possibly <code>inclusive</code>.\nThe type of the iteration.\nThe binding / variable to introduce in the body <code>block</code>.\nA return statement <code>return expression;</code>.\nThe expression to return to the function caller.\nThe ID of the node.\nThe span of <code>return expression</code> excluding the semicolon.\nA composite type definition, e.g., …\nThe composite’s const parameters.\nThe external program the struct is defined in.\nThe ID of the node.\nThe name of the type in the type system in this module.\nWas this a <code>record Foo { ... }</code>? If so, it wasn’t a …\nThe fields, constant variables, and functions of this …\nReturns the composite name as a Symbol.\nThe entire span of the composite definition.\nA member of a structured data type, e.g <code>foobar: u8</code> or …\nThe ID of the node.\nThe identifier of the member.\nThe mode of the member.\nReturns the name of the struct member without span.\nThe span of the member.\nThe type of the member.\nStores the Leo stub abstract syntax tree.\nA vector of const definitions.\nA vector of function stub definitions.\nA vector of imported programs.\nA vector of mapping definitions.\nThe span associated with the stub.\nA vector of struct definitions.\nThe stub id\nA function stub definition.\nAnnotations on the function.\nPrivate formatting method used for optimizing fmt::Debug …\nConverts from snarkvm function type to leo FunctionStub, …\nThe ID of the node.\nThe function identifier, e.g., <code>foo</code> in …\nThe function’s input parameters.\nReturns <code>true</code> if the function name is <code>main</code>.\nReturns function name.\nInitialize a new function.\nThe function’s output declarations.\nThe function’s output type.\nThe entire span of the function definition.\nIs this function a transition, inlined, or a regular …\nAn array type.\nReturns the base element type of the array.\nReturns the element type of the array.\nCreates a new array type.\nA core constant that maps directly to an AVM bytecode …\nReturns a <code>CoreConstant</code> from the given type and constant …\nReturns the <code>Type</code> of the <code>CoreConstant</code>.\nA future type consisting of the type of the inputs.\nReturns the inputs of the future type.\nReturns the location of the future type.\nInitialize a new future type.\nExplicit integer type.\nIs the integer type a signed one?\nReturns the symbol for the integer type.\nA mapping type of a key and value type.\nA composite type of a identifier and external program name.\nExpressions for the const arguments passed to the struct’…\nThe path to the composite definition.\nThe external program that this composite is defined in.\nA type list of at least two types.\nReturns the elements of the tuple type.\nReturns the length of the tuple type.\nCreates a new tuple type.\nThe <code>address</code> type.\nThe array type.\nThe <code>bool</code> type.\nThe <code>struct</code> type.\nPlaceholder for a type that could not be resolved or was …\nThe <code>field</code> type.\nThe <code>future</code> type.\nThe <code>group</code> type.\nA reference to a built in type.\nAn integer type.\nA mapping type.\nNumeric type which should be resolved to <code>Field</code>, <code>Group</code>, …\nThe <code>scalar</code> type.\nThe <code>signature</code> type.\nThe <code>string</code> type.\nA static tuple of at least one type.\nExplicit type used for defining a variable or expression …\nThe <code>unit</code> type.\nReturns <code>true</code> if the self <code>Type</code> is equal to the other <code>Type</code> …")