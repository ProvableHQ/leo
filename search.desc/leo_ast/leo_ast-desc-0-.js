searchState.loadedDescShard("leo_ast", 0, "The abstract syntax tree (ast) for a Leo program.\nThe abstract syntax tree (AST) for a Leo program.\nReturns a reference to the inner program AST …\nReturns the argument unchanged.\nDeserializes the JSON string into a ast from a file.\nDeserializes the JSON string into a ast.\nCalls <code>U::from(self)</code>.\nCreates a new AST from a given program tree.\nHelper function to normalize AST JSON into a form …\nThis module contains both a Reducer and Visitor design …\nA Leo program consists of import statements and program …\nHelper function to recursively filter keys from AST JSON\nA stub contains function templates as well as definitions …\nSerializes the ast into a JSON file.\nSerializes the ast into a JSON value and removes keys from …\nSerializes the ast into a JSON string.\nAn array access expression, e.g., <code>foo[index]</code>.\nA struct member access expression <code>inner.name</code> to some …\nA tuple access expression, e.g., <code>tuple.index</code>.\nAn expression evaluating to some array type, e.g., …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe index to access in the array expression. E.g., <code>0</code> for …\nThe index to access in the tuple expression. E.g., <code>0</code> for …\nThe inner struct that is being accessed.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe name of the struct member to access.\nThe span for the entire expression <code>foo[index]</code>.\nThe span covering all of <code>inner.name</code>.\nThe span for the entire expression <code>tuple.index</code>.\nAn expression evaluating to some tuple type, e.g., <code>(5, 2)</code>.\nAn array access expression, e.g., <code>foo[index]</code>.\nAn expression evaluating to some array type, e.g., …\nThe ID of the node.\nThe index to access in the array expression. E.g., <code>0</code> for …\nThe span for the entire expression <code>foo[index]</code>.\nA struct member access expression <code>inner.name</code> to some …\nThe ID of the node.\nThe inner struct that is being accessed.\nThe name of the struct member to access.\nThe span covering all of <code>inner.name</code>.\nA tuple access expression, e.g., <code>tuple.index</code>.\nThe ID of the node.\nThe index to access in the tuple expression. E.g., <code>0</code> for …\nThe span for the entire expression <code>tuple.index</code>.\nAn expression evaluating to some tuple type, e.g., <code>(5, 2)</code>.\nAn identifier in a program.\nReturns the argument unchanged.\nThe ID of the node.\nCalls <code>U::from(self)</code>.\nCheck if the Identifier name matches the other name.\nThe symbol that the user wrote, e.g., <code>foo</code>.\nConstructs a new identifier with <code>name</code> and <code>id</code> and a default …\nA span locating where the identifier occurred in the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA node in the AST.\nA node ID.\nReturns the ID of the node.\nSets the ID of the node.\nSets the span of the node.\nReturns the span of the node.\nA counter that produces sequentially increasing <code>NodeID</code>s.\nContains the actual data for <code>Handler</code>. Modeled this way to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe inner counter. <code>RefCell</code> is used here to avoid <code>&amp;mut</code> all …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns a new <code>NodeCounter</code> with the given <code>NodeID</code> as the …\nReturns a new <code>NodeCounter</code> with the given <code>NodeID</code> as the …\nThe next <code>NodeID</code>.\nReturns the next <code>NodeID</code> and increments the internal state.\nReturns the next <code>NodeID</code> and increments the internal state.\nA number string guaranteed to be non-negative.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if this number is zero.\nReturns the string representation of the non-negative …\nThe string representation of the non-negative number.\nReturns the numeric value of the non-negative number.\nThe numeric value of the non-negative number.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAbsolute value checking for overflow, i.e. <code>.abs()</code>.\nAbsolute value wrapping around at the boundary of the …\nA struct access expression, e.g. <code>Foo.bar</code>.\nAn access expressions, extracting a smaller part out of a …\nAddition, i.e. <code>+</code>, <code>.add()</code>.\nWrapping addition, i.e. <code>.add_wrapped()</code>.\nAn address literal, e.g., …\nLogical AND, i.e. <code>&amp;&amp;</code>.\nAn <code>array[index]</code> expression.\nAn array expression, e.g., <code>[true, false, true, false]</code>.\nAn array expression, e.g., <code>[true, false, true, false]</code>.\nAn associated constant; e.g., <code>group::GEN</code>.\nAn access expression to an struct constant., e.g. <code>u8::MAX</code>.\nAn associated function; e.g., <code>BHP256::hash_to_field</code>.\nAn access expression to an associated function in a …\nA binary expression, e.g., <code>42 + 24</code>.\nA binary expression <code>left op right</code> of two operands …\nA binary operator.\nBitwise AND, i.e. <code>&amp;</code>, <code>.and()</code>.\nBitwise OR, i.e. <code>|</code>, <code>.or()</code>.\nA boolean literal, either <code>true</code> or <code>false</code>.\nA call expression, e.g., <code>my_fun(args)</code>.\nA function call expression, e.g.<code>foo(args)</code> or <code>Foo::bar(args)</code>…\nA cast expression, e.g., <code>42u32 as u8</code>.\nA cast expression, e.g. <code>42u8 as u16</code>.\nDivision, i.e. <code>/</code>, <code>.div()</code>.\nWrapping division, i.e. <code>.div_wrapped()</code>.\nDouble operation, i.e. <code>.double()</code>.\nEquality relation, i.e. <code>==</code>, <code>.eq()</code>.\nAn expression of type “error”. Will result in a …\nRepresents a syntactically invalid expression.\nExpression that evaluates to a value.\nA field literal, e.g., <code>42field</code>. A signed number followed …\nThis trait allows to parse integer literals of any type …\nA group literal, eg <code>42group</code>.\nGreater-than relation, i.e. <code>&gt;</code>, <code>.gt()</code>.\nGreater-or-equal relation, i.e. <code>&gt;=</code>, <code>.gte()</code>.\nAn identifier.\nAn integer literal, e.g., <code>42</code>.\nMultiplicative inverse, i.e. <code>.inv()</code>.\nA literal.\nA literal expression.\nA locator expression, e.g., <code>hello.aleo/foo</code>.\nLesser-than relation, i.e. <code>&lt;</code>, <code>.lt()</code>.\nLesser-or-equal relation, i.e. <code>&lt;=</code>, <code>.lte()</code>.\nAn expression accessing a field in a structure, e.g., …\nArithmetic modulo, i.e. <code>.mod()</code>\nMultiplication, i.e. <code>*</code>, <code>.mul()</code>.\nWrapping multiplication, i.e. <code>.mul_wrapped()</code>.\nBoolean NAND, i.e. <code>.nand()</code>.\nNegate operation, i.e. <code>.neg()</code>.\nIn-equality relation, i.e. <code>!=</code>, <code>.neq()</code>.\nBoolean NOR, i.e. <code>.nor()</code>.\nBitwise NOT, i.e. <code>!</code>, <code>.not()</code>.\nLogical OR, i.e. <code>||</code>.\nExponentiation, i.e. <code>**</code> in <code>a ** b</code>, <code>.pow()</code>.\nWrapping exponentiation, i.e. <code>.pow_wrapped()</code>.\nRemainder, i.e. <code>%</code>, <code>.rem()</code>.\nWrapping remainder, i.e. <code>.rem_wrapped()</code>.\nA scalar literal, e.g. <code>1scalar</code>. An unsigned number …\nShift left operation, i.e. <code>&lt;&lt;</code>, <code>.shl()</code>.\nWrapping shift left operation, i.e. <code>.shl_wrapped()</code>.\nShift right operation, i.e. &gt;&gt;, <code>.shr()</code>.\nWrapping shift right operation, i.e. <code>.shr_wrapped()</code>.\nSquare operation, i.e. <code>.square()</code>.\nSquare root operation, i.e. <code>.sqrt()</code>.\nA string literal, e.g., <code>&quot;foobar&quot;</code>.\nAn expression constructing a struct like …\nA struct initialization expression, e.g., …\nAn initializer for a single field / variable of a struct …\nSubtraction, i.e. <code>-</code>, <code>.sub()</code>.\nWrapped subtraction, i.e. <code>.sub_wrapped()</code>.\nA ternary conditional expression <code>cond ? if_expr : else_expr</code>…\nA ternary conditional expression, that is, …\nConverts a group element to its x-coordinate, i.e. …\nConverts a group element to its y-coordinate, i.e. …\nAccess to a tuple field using its position, e.g., <code>tuple.1</code>.\nA tuple expression e.g., <code>(foo, 42, true)</code>.\nA tuple expression, e.g., <code>(foo, false, 42)</code>.\nAn unary expression.\nAn unary expression applying an operator to an inner …\nA unary operator for a unary expression.\nA unit expression e.g. <code>()</code>\nRepresents a unit expression.\nBitwise XOR, i.e. <code>.xor()</code>.\nThe arguments passed to the function <code>name</code>.\nExpressions for the arguments passed to the functions …\nThe condition determining which branch to pick.\nThe elements of the array.\nThe elements of the tuple. In the example above, it would …\nThe expression to be casted, e.g.<code>42u8</code> in <code>42u8 as u16</code>.\nThe expression to initialize the field with. When <code>None</code>, a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAn expression evaluating to a callable function, either a …\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the expression.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe ID of the node.\nThe name of the field / variable to be initialized.\nThe branch the expression evaluates to if <code>condition</code> …\nThe branch the expression evaluates to if <code>condition</code> …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe left operand of the expression.\nInitializer expressions for each of the fields in the …\nThe struct constant that is being accessed.\nThe static struct member function that is being accessed.\nThe name of the structure type to initialize.\nThe operand defining the meaning of the resulting binary …\nThe unary operator to apply to <code>inner</code>.\nThe name of the parent program call, e.g.<code>bar</code> in <code>bar.aleo</code>.\nThe inner expression <code>op</code> is applied to.\nThe right operand of the expression.\nThe span for the entire expression <code>Foo::bar()</code>.\nThe span for the entire expression <code>Foo::bar()</code>.\nThe span from <code>[</code> to <code>]</code>.\nThe span from <code>left</code> to <code>right</code>.\nSpan of the entire call <code>function(arguments)</code>.\nSpan of the entire cast <code>42u8 as u16</code>.\nThe span of the node.\nA span from <code>name</code> to <code>}</code>.\nThe span of the invalid expression.\nThe span from <code>condition</code> to <code>if_false</code>.\nThe span from <code>(</code> to <code>)</code>.\nThe span covering <code>op inner</code>.\nThe span of the unit expression.\nThe inner struct type.\nThe type to be casted to, e.g. <code>u16</code> in <code>42u8 as u16</code>.\nThe inner struct variant.\nAn access expressions, extracting a smaller part out of a …\nAn <code>array[index]</code> expression.\nAn expression accessing a field in a structure, e.g., …\nAccess to a tuple field using its position, e.g., <code>tuple.1</code>.\nAn array expression, e.g., <code>[true, false, true, false]</code>.\nThe elements of the array.\nThe ID of the node.\nThe span from <code>[</code> to <code>]</code>.\nAn access expression to an struct constant., e.g. <code>u8::MAX</code>.\nThe ID of the node.\nThe struct constant that is being accessed.\nThe span for the entire expression <code>Foo::bar()</code>.\nThe inner struct type.\nAn access expression to an associated function in a …\nThe arguments passed to the function <code>name</code>.\nThe ID of the node.\nThe static struct member function that is being accessed.\nThe span for the entire expression <code>Foo::bar()</code>.\nThe inner struct variant.\nAddition, i.e. <code>+</code>, <code>.add()</code>.\nWrapping addition, i.e. <code>.add_wrapped()</code>.\nLogical AND, i.e. <code>&amp;&amp;</code>.\nA binary expression <code>left op right</code> of two operands …\nA binary operator.\nBitwise AND, i.e. <code>&amp;</code>, <code>.and()</code>.\nBitwise OR, i.e. <code>|</code>, <code>.or()</code>.\nDivision, i.e. <code>/</code>, <code>.div()</code>.\nWrapping division, i.e. <code>.div_wrapped()</code>.\nEquality relation, i.e. <code>==</code>, <code>.eq()</code>.\nGreater-than relation, i.e. <code>&gt;</code>, <code>.gt()</code>.\nGreater-or-equal relation, i.e. <code>&gt;=</code>, <code>.gte()</code>.\nLesser-than relation, i.e. <code>&lt;</code>, <code>.lt()</code>.\nLesser-or-equal relation, i.e. <code>&lt;=</code>, <code>.lte()</code>.\nArithmetic modulo, i.e. <code>.mod()</code>\nMultiplication, i.e. <code>*</code>, <code>.mul()</code>.\nWrapping multiplication, i.e. <code>.mul_wrapped()</code>.\nBoolean NAND, i.e. <code>.nand()</code>.\nIn-equality relation, i.e. <code>!=</code>, <code>.neq()</code>.\nBoolean NOR, i.e. <code>.nor()</code>.\nLogical OR, i.e. <code>||</code>.\nExponentiation, i.e. <code>**</code> in <code>a ** b</code>, <code>.pow()</code>.\nWrapping exponentiation, i.e. <code>.pow_wrapped()</code>.\nRemainder, i.e. <code>%</code>, <code>.rem()</code>.\nWrapping remainder, i.e. <code>.rem_wrapped()</code>.\nShift left operation, i.e. <code>&lt;&lt;</code>, <code>.shl()</code>.\nWrapping shift left operation, i.e. <code>.shl_wrapped()</code>.\nShift right operation, i.e. &gt;&gt;, <code>.shr()</code>.\nWrapping shift right operation, i.e. <code>.shr_wrapped()</code>.\nSubtraction, i.e. <code>-</code>, <code>.sub()</code>.\nWrapped subtraction, i.e. <code>.sub_wrapped()</code>.\nBitwise XOR, i.e. <code>.xor()</code>.\nReturns a <code>BinaryOperation</code> from the given <code>Symbol</code>. This is …\nThe ID of the expression.\nThe left operand of the expression.\nThe operand defining the meaning of the resulting binary …\nThe right operand of the expression.\nThe span from <code>left</code> to <code>right</code>.\nA function call expression, e.g.<code>foo(args)</code> or <code>Foo::bar(args)</code>…\nExpressions for the arguments passed to the functions …\nAn expression evaluating to a callable function, either a …\nThe ID of the node.\nThe name of the parent program call, e.g.<code>bar</code> in <code>bar.aleo</code>.\nSpan of the entire call <code>function(arguments)</code>.\nA cast expression, e.g. <code>42u8 as u16</code>.\nThe expression to be casted, e.g.<code>42u8</code> in <code>42u8 as u16</code>.\nThe ID of the node.\nSpan of the entire cast <code>42u8 as u16</code>.\nThe type to be casted to, e.g. <code>u16</code> in <code>42u8 as u16</code>.\nRepresents a syntactically invalid expression.\nThe ID of the node.\nThe span of the invalid expression.\nAn address literal, e.g., …\nA boolean literal, either <code>true</code> or <code>false</code>.\nA field literal, e.g., <code>42field</code>. A signed number followed …\nThis trait allows to parse integer literals of any type …\nA group literal, eg <code>42group</code>.\nAn integer literal, e.g., <code>42</code>.\nA literal.\nA scalar literal, e.g. <code>1scalar</code>. An unsigned number …\nA string literal, e.g., <code>&quot;foobar&quot;</code>.\nFor displaying a literal as decimal, regardless of the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA locator that references an external resource.\nReturns the argument unchanged.\nThe ID of the node.\nCalls <code>U::from(self)</code>.\nCheck if the Locator name and program matches the other …\nThe name of the resource.\nConstructs a new Locator with <code>name</code>, <code>program</code> and <code>id</code> and a …\nThe program that the resource is in.\nA span indicating where the locator occurred in the source.\nA struct initialization expression, e.g., …\nAn initializer for a single field / variable of a struct …\nReturns true if the record has all required fields and …\nThe expression to initialize the field with. When <code>None</code>, a …\nThe ID of the node.\nThe ID of the node.\nThe name of the field / variable to be initialized.\nInitializer expressions for each of the fields in the …\nThe name of the structure type to initialize.\nThe span of the node.\nA span from <code>name</code> to <code>}</code>.\nReturns the struct as a record interface with visibility.\nA ternary conditional expression, that is, …\nThe condition determining which branch to pick.\nThe ID of the node.\nThe branch the expression evaluates to if <code>condition</code> …\nThe branch the expression evaluates to if <code>condition</code> …\nThe span from <code>condition</code> to <code>if_false</code>.\nA tuple expression, e.g., <code>(foo, false, 42)</code>.\nThe elements of the tuple. In the example above, it would …\nThe ID of the node.\nThe span from <code>(</code> to <code>)</code>.\nAbsolute value checking for overflow, i.e. <code>.abs()</code>.\nAbsolute value wrapping around at the boundary of the …\nDouble operation, i.e. <code>.double()</code>.\nMultiplicative inverse, i.e. <code>.inv()</code>.\nNegate operation, i.e. <code>.neg()</code>.\nBitwise NOT, i.e. <code>!</code>, <code>.not()</code>.\nSquare operation, i.e. <code>.square()</code>.\nSquare root operation, i.e. <code>.sqrt()</code>.\nConverts a group element to its x-coordinate, i.e. …\nConverts a group element to its y-coordinate, i.e. …\nAn unary expression applying an operator to an inner …\nA unary operator for a unary expression.\nRepresents the operator as a string.\nReturns a <code>UnaryOperation</code> from the given <code>Symbol</code>.\nThe ID of the node.\nThe unary operator to apply to <code>inner</code>.\nThe inner expression <code>op</code> is applied to.\nThe span covering <code>op inner</code>.\nRepresents a unit expression.\nThe ID of the node.\nThe span of the unit expression.\nA function definition.\nAnnotations on the function.\nThe body of the function.\nReturns the argument unchanged.\nThe ID of the node.\nThe function identifier, e.g., <code>foo</code> in …\nThe function’s input parameters.\nCalls <code>U::from(self)</code>.\nReturns function name.\nInitialize a new function.\nThe function’s output declarations.\nThe function’s output type.\nThe entire span of the function definition.\nIs this function a transition, inlined, or a regular …\nAn annotation, e.g. @program.\nReturns the argument unchanged.\nThe ID of the node.\nThe name of the annotation.\nCalls <code>U::from(self)</code>.\nA span locating where the annotation occurred in the …\nA core instruction that maps directly to an AVM bytecode …\nReturns the argument unchanged.\nReturns a <code>CoreFunction</code> from the given module and method …\nCalls <code>U::from(self)</code>.\nReturns whether or not this function is finalize command.\nReturns the number of arguments required by the …\nA function parameter.\nReturns the argument unchanged.\nThe ID of the node.\nThe name the parameter is accessible as in the function’…\nCalls <code>U::from(self)</code>.\nThe mode of the function parameter.\nThe parameters span from any annotations to its type.\nWhat’s the parameter’s type?\nThe mode associated with a type.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA function output.\nReturns the argument unchanged.\nThe ID of the node.\nCalls <code>U::from(self)</code>.\nThe mode of the function output.\nThe parameters span from any annotations to its type.\nThe type of the function output.\nFunctions are always one of five variants. A transition …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns true if the variant is async.\nReturns true if the variant is an async function.\nReturns true if the variant is a function.\nReturns true if the variant is a transition.\nImplements <code>Display</code> by putting 4 spaces in front of each …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA mapping declaration, e.g …\nReturns the argument unchanged.\nThe ID of the node.\nThe name of the mapping.\nCalls <code>U::from(self)</code>.\nThe type of the key.\nThe entire span of the mapping declaration.\nThe type of the value.\nThis module contains a Consumer trait for the AST. …\nThis module contains a Reconstructor trait for the AST. It …\nThis module contains Visitor trait implementations for the …\nA Consumer trait for expressions in the AST.\nA Consumer trait for functions in the AST.\nA Consumer trait for imported programs in the AST.\nA Consumer trait for mappings in the AST.\nA Consumer trait for the program represented by the AST.\nA Consumer trait for program scopes in the AST.\nA Consumer trait for statements in the AST.\nA Consumer trait for structs in the AST.\nA Reconstructor trait for expressions in the AST.\nA Reconstructor trait for the program represented by the …\nA Reconstructor trait for statements in the AST.\nA Visitor trait for expressions in the AST.\nA Visitor trait for the program represented by the AST.\nA Visitor trait for statements in the AST.\nStores the Leo program abstract syntax tree.\nConstructs an empty program node.\nReturns the argument unchanged.\nA map from import names to import definitions.\nCalls <code>U::from(self)</code>.\nA Leo program scope consists of struct, function, and …\nA map from program names to program scopes.\nA map from program stub names to program stub scopes.\nAn identifier for a program that is eventually deployed to …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe name of the program.\nThe network associated with the program.\nStores the Leo program scope abstract syntax tree.\nA vector of const definitions\nReturns the argument unchanged.\nA vector of function definitions.\nCalls <code>U::from(self)</code>.\nA vector of mapping definitions.\nThe program id of the program scope.\nThe span associated with the program scope.\nA vector of struct definitions.\nAn assert statement.\nAn assignment statement.\nA block statement.\nAn <code>if</code> statement.\nA console logging statement.\nA binding from identifier to constant value.\nA binding or set of bindings / variables to declare.\nAn expression statement\nA <code>for</code> statement.\nA return statement <code>return expr;</code>.\nProgram statement that defines some action (or expression) …\nReturns a dummy statement made from an empty block <code>{}</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA <code>assert(expr)</code> variant, asserting that the expression …\nA <code>assert_eq(expr1, expr2)</code> variant, asserting that the …\nA <code>assert_neq(expr1, expr2)</code> variant, asserting that the …\nAn assert statement, <code>assert(&lt;expr&gt;)</code>, <code>assert_eq(&lt;expr&gt;)</code> or …\nA variant of an assert statement.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe ID of the node.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe span, excluding the semicolon.\nThe variant of the assert statement.\nAn assignment statement, <code>assignee = value</code>. Note that there …\nReturns the argument unchanged.\nThe ID of the node.\nCalls <code>U::from(self)</code>.\nThe identifier to assign to.\nThe span, excluding the semicolon.\nThe value to assign to the <code>assignee</code>.\nA block <code>{ [stmt]* }</code> consisting of a list of statements to …\nReturns the argument unchanged.\nThe ID of the node.\nCalls <code>U::from(self)</code>.\nThe span from <code>{</code> to <code>}</code>.\nThe list of statements to execute.\nAn <code>if condition block (else next)?</code> statement.\nThe <code>bool</code>-typed condition deciding what to evaluate.\nReturns the argument unchanged.\nThe ID of the node.\nCalls <code>U::from(self)</code>.\nThe statement, if any, to evaluate when <code>condition</code> yields …\nThe span from <code>if</code> to <code>next</code> or to <code>block</code>.\nThe block to evaluate in case <code>condition</code> yields <code>true</code>.\nA <code>console.assert(expr)</code> call to invoke, asserting that the …\nA <code>console.assert_eq(expr1, expr2)</code> call to invoke, …\nA <code>console.assert_neq(expr1, expr2)</code> call to invoke, …\nA console logging function to invoke.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA console logging statement like <code>console.log(...);</code>.\nReturns the argument unchanged.\nThe logging function to run.\nThe ID of the node.\nCalls <code>U::from(self)</code>.\nThe span excluding the semicolon.\nA constant declaration statement.\nReturns the argument unchanged.\nThe ID of the node.\nCalls <code>U::from(self)</code>.\nThe place to assign to. As opposed to <code>DefinitionStatement</code>, …\nThe span excluding the semicolon.\nThe type of the binding, if specified, or inferred …\nAn initializer value for the binding.\nA <code>let</code> or <code>const</code> declaration statement.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe ID of the node.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe bindings / variable names to declare.\nThe span excluding the semicolon.\nThe types of the bindings, if specified, or inferred …\nAn initializer value for the bindings.\nAn expression statement, <code>foo(a);</code>.\nThe expression associated with the statement.\nReturns the argument unchanged.\nThe ID of the node.\nCalls <code>U::from(self)</code>.\nThe span.\nA bounded <code>for</code> loop statement …\nThe block to run on each iteration.\nReturns the argument unchanged.\nThe ID of the node.\nWhether <code>stop</code> is inclusive or not. Signified with <code>=</code> when …\nCalls <code>U::from(self)</code>.\nThe span from <code>for</code> to <code>block</code>.\nThe start of the iteration.\nThe concrete value of <code>start</code>.\nThe end of the iteration, possibly <code>inclusive</code>.\nThe concrete value of <code>stop</code>.\nThe type of the iteration.\nThe binding / variable to introduce in the body <code>block</code>.\nA return statement <code>return expression;</code>.\nThe expression to return to the function caller.\nReturns the argument unchanged.\nThe ID of the node.\nCalls <code>U::from(self)</code>.\nThe span of <code>return expression</code> excluding the semicolon.\nA composite type definition, e.g., …\nThe external program the struct is defined in.\nReturns the argument unchanged.\nThe ID of the node.\nThe name of the type in the type system in this module.\nCalls <code>U::from(self)</code>.\nWas this a <code>record Foo { ... }</code>? If so, it wasn’t a …\nThe fields, constant variables, and functions of this …\nReturns the composite name as a Symbol.\nThe entire span of the composite definition.\nA member of a structured data type, e.g <code>foobar: u8</code> or …\nReturns the argument unchanged.\nThe ID of the node.\nThe identifier of the member.\nCalls <code>U::from(self)</code>.\nThe mode of the member.\nReturns the name of the struct member without span.\nThe span of the member.\nThe type of the member.\nStores the Leo stub abstract syntax tree.\nA vector of const definitions.\nConstructs an empty program stub\nReturns the argument unchanged.\nA vector of function stub definitions.\nA vector of imported programs.\nCalls <code>U::from(self)</code>.\nA vector of mapping definitions.\nThe span associated with the stub.\nA vector of struct definitions.\nThe stub id\nA function stub definition.\nAnnotations on the function.\nPrivate formatting method used for optimizing fmt::Debug …\nReturns the argument unchanged.\nConverts from snarkvm function type to leo FunctionStub, …\nThe ID of the node.\nThe function identifier, e.g., <code>foo</code> in …\nThe function’s input parameters.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the function name is <code>main</code>.\nReturns function name.\nInitialize a new function.\nThe function’s output declarations.\nThe function’s output type.\nThe entire span of the function definition.\nIs this function a transition, inlined, or a regular …\nAn array type.\nReturns the base element type of the array.\nReturns the element type of the array.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the length of the array.\nCreates a new array type.\nA core constant that maps directly to an AVM bytecode …\nReturns the argument unchanged.\nReturns a <code>CoreConstant</code> from the given type and constant …\nCalls <code>U::from(self)</code>.\nReturns the <code>Type</code> of the <code>CoreConstant</code>.\nA future type consisting of the type of the inputs.\nReturns the argument unchanged.\nReturns the inputs of the future type.\nCalls <code>U::from(self)</code>.\nReturns the location of the future type.\nInitialize a new future type.\nExplicit integer type.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIs the integer type a signed one?\nReturns the symbol for the integer type.\nA mapping type of a key and value type.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA composite type of a identifier and external program name.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA type list of at least two types.\nReturns the elements of the tuple type.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the length of the tuple type.\nCreates a new tuple type.\nThe <code>address</code> type.\nThe array type.\nThe <code>bool</code> type.\nThe <code>struct</code> type.\nPlaceholder for a type that could not be resolved or was …\nThe <code>field</code> type.\nThe <code>future</code> type.\nThe <code>group</code> type.\nA reference to a built in type.\nAn integer type.\nA mapping type.\nThe <code>scalar</code> type.\nThe <code>signature</code> type.\nThe <code>string</code> type.\nA static tuple of at least one type.\nExplicit type used for defining a variable or expression …\nThe <code>unit</code> type.\nReturns <code>true</code> if the self <code>Type</code> is equal to the other <code>Type</code> …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConverts a literal to a value.")