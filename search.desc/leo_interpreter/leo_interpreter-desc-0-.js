searchState.loadedDescShard("leo_interpreter", 0, "A context in which we can evaluate core functions.\nGlobal values - such as mappings, functions, etc - are …\nA Leo value of any type.\nEvaluate a binary operation.\nEvaluate a unary operation.\nRun interpreter tests and return data about native tests.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nLoad all the Leo source files indicated and open the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA context in which we can evaluate core functions.\nA Leo block.\nA stack of contexts, building with the function call stack.\nTracks the current execution state - a cursor into the …\nA Leo construct to be evauated.\nA Leo expression.\nA frame of execution, keeping track of the Element next to …\nNames associated to values in a function being executed.\nGlobal values - such as mappings, functions, etc - are …\nA Leo statement.\nEvaluate a binary operation.\nEvaluate a unary operation.\nHas this element completely finished running?\nStack of execution frames, with the one currently to be …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAll functions (or transitions or inlines) in any program …\nGet the future accumulated by awaiting futures in the …\nConsts are stored here.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAre we currently in an async function?\n<code>really_async</code> indicates we should really delay execution of …\nStep <code>over</code> the current Element.\nExecute one step of the current element.\nFor each struct type, we only need to remember the names …\nIf the element was an expression, here’s its value.\nStack of values from evaluated expressions.\nExecute the whole step of the current Element.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nContains the state of interpretation, in the form of the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns false if there was no saved cursor to restore.\nReturns true if any watchpoints changed.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA Leo value of any type.\nConvert to the given type if possible under Aleo casting …\nAre the values equal, according to SnarkVM?\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn the group generator.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDoesn’t correspond to Aleo’s shl, because it does not …")