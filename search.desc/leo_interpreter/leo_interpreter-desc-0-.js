searchState.loadedDescShard("leo_interpreter", 0, "Run interpreter tests and return data about native tests.\nReturns the argument unchanged.\nLoad all the Leo source files indicated and open the …\nCalls <code>U::from(self)</code>.\nA Leo block.\nA stack of contexts, building with the function call stack.\nTracks the current execution state - a cursor into the …\nA Leo construct to be evauated.\nA Leo expression. The optional type is an optional “…\nA frame of execution, keeping track of the Element next to …\nNames associated to values in a function being executed.\nA Leo statement.\nAll the async blocks encountered. We identify them by …\nHas this element completely finished running?\nStack of execution frames, with the one currently to be …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAll functions (or transitions or inlines) in any program …\nGet the future accumulated by awaiting futures in the …\nConsts are stored here.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAre we currently in an async function?\n<code>really_async</code> indicates we should really delay execution of …\nStep <code>over</code> the current Element.\nExecute one step of the current element.\nFor each struct type, we only need to remember the names …\nIf the element was an expression, here’s its value.\nStack of values from evaluated expressions.\nExecute the whole step of the current Element.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nContains the state of interpretation, in the form of the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns false if there was no saved cursor to restore.\nReturns true if any watchpoints changed.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")