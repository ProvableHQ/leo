searchState.loadedDescShard("leo_passes", 0, "leo-passes\nA struct used to create assignment statements.\nContains the actual data for <code>Assigner</code>. Modeled this way to …\nA call graph.\nContains data share by many compiler passes.\nA binary search tree to store all paths through nested …\nA pass to perform const propagation and folding.\nPass that runs const propagation and loop unrolling until …\nAn error that is emitted when a cycle is detected in the …\nA pass to rewrite tuple creation and accesses into other …\nA directed graph.\nErrors in directed graph operations.\nAn import dependency graph.\nA node in a graph.\nA compiler pass.\nA pass to validate (and remove) uses of <code>interpret</code>.\n<code>RenameTable</code> tracks the names assigned by static single …\nA <code>Replacer</code> applies <code>replacer</code> to all <code>Identifier</code>s in an AST. …\nA struct dependency graph.\nMaps global and local symbols to information about them.\nA pass to fill the SymbolTable.\nA pass to check types.\nSpecify network limits for type checking.\nA mapping between node IDs and their types.\nAn entry for a variable in the symbol table.\nAn enumeration of the different types of variable type.\nA pass to rewrite assignments to array accesses and struct …\nLocal tables index by the NodeID of the function, …\nAn array index which was not able to be evaluated.\nAn array length which was not able to be evaluated.\nCreates unique symbols and definitions.\nThe Abstract Syntax Tree.\nA graph of which functions call each other.\nSomething about the program was actually changed during …\nDid we change anything in this program?\nA const declaration whose RHS was not able to be evaluated.\nA counter.\nA strictly increasing counter, used to ensure that new …\nThe Dead Code Elimination pass traverses the AST and …\nThe type of declaration for the variable.\nThe current depth.\nThe destructuring pass traverses the AST and destructures …\nRuns the compiler pass.\nThe directed edges in the graph. Each entry in the map is …\nThe directed edges in the graph. Each entry in the map is …\nThe directed edges in the graph. Each entry in the map is …\nThe directed edges in the graph. Each entry in the map is …\nThe current node.\nThe flattening pass traverses the AST after the SSA pass …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe Function Inlining pass traverses the AST and inlines …\nFunctions indexed by location.\nThe locations of the futures passed to the async function …\nConsts that have been successfully evaluated.\nGlobal variables indexed by location.\nThe error Handler.\nThe mapping from symbols to node IDs. These are used to …\nThe types passed to the async function called by this …\nThe inner counter. <code>RefCell</code> is used here to avoid <code>&amp;mut</code> all …\nThe inner table. <code>RefCell</code> is used here to avoid <code>&amp;mut</code> all …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this a test program?\nThe current LocalTable we’re looking at.\nThe name of the async function this async transition calls.\nIf we encountered a loop that was not unrolled, here’s it…\nDid we unroll any loop?\nPerforms monomorphization of const generic functions …\nThe mapping from names in the original AST to new names in …\nCreates incrementing node IDs.\nThe set of nodes in the graph.\nThe set of nodes in the graph.\nThe set of nodes in the graph.\nThe set of nodes in the graph.\nThe <code>RenameTable</code> of the parent scope.\nRecords indexed by location.\nA repeat expression count which was not able to be …\nThe <code>Span</code> associated with the variable.\nThe Static Single Assignment pass traverses the AST and …\nA graph of which structs refer to each other.\nStructs indexed by location.\nContains data about the variables and other entities in …\nThe <code>Type</code> of the variable.\nMaps node IDs to types.\nIf we encountered calls to const generic functions that …\nIf we encountered const generic struct expressions that …\nIf we encountered const generic struct type instantiations …\nA set of the warnings collected. This is used to make sure …\nMapping of composite names to a tuple containing metadata …\nThe depth of the current conditional block.\nReference to the current function.\nA reference to the finalize caller.\nReturns the argument unchanged.\nMapping of global identifiers to their associated names.\nInternal record input registers of the current function. …\nCalls <code>U::from(self)</code>.\nLegalize a struct name. If it’s already legal, then just …\nA counter to track the next available label.\nA counter to track the next available register.\nA reference to program. This is needed to look up external …\nThe program ID of the current program.\nGiven a struct name as a <code>&amp;str</code>, transform it into a legal …\nMapping of variables to registers.\nThe variant of the function we are currently traversing.\nA struct used to create assignment statements.\nContains the actual data for <code>Assigner</code>. Modeled this way to …\nA strictly increasing counter, used to ensure that new …\nThe inner counter. <code>RefCell</code> is used here to avoid <code>&amp;mut</code> all …\nConstructs the definition statement <code>let place = expr;</code>. …\nConstructs the definition statement <code>let place = expr;</code>. …\nReturn a new unique <code>Symbol</code> from a <code>&amp;str</code>.\nReturn a new unique <code>Symbol</code> from a <code>&amp;str</code>.\nA call graph.\nAn error that is emitted when a cycle is detected in the …\nA directed graph.\nErrors in directed graph operations.\nAn import dependency graph.\nA node in a graph.\nA struct dependency graph.\nAdds an edge to the graph.\nReturns <code>true</code> if the graph contains the given node.\nThe directed edges in the graph. Each entry in the map is …\nThe directed edges in the graph. Each entry in the map is …\nThe directed edges in the graph. Each entry in the map is …\nThe directed edges in the graph. Each entry in the map is …\nReturns the set of immediate neighbors of a given node.\nInitializes a new <code>DiGraph</code> from a vector of source nodes.\nThe set of nodes in the graph.\nThe set of nodes in the graph.\nThe set of nodes in the graph.\nThe set of nodes in the graph.\nReturns the post-order ordering of the graph. Detects if …\nReturns the post-order ordering of the graph but only …\nRemoves a node and all associated edges from the graph.\nRetains a subset of the nodes, and removes all edges in …\n<code>RenameTable</code> tracks the names assigned by static single …\nThe mapping from symbols to node IDs. These are used to …\nReturns the symbols that were renamed in the current scope.\nLooks up the new name for <code>symbol</code>, recursively checking the …\nLooks up the node ID for <code>symbol</code>, recursively checking the …\nThe mapping from names in the original AST to new names in …\nCreate a new <code>RenameTable</code> with the given parent.\nThe <code>RenameTable</code> of the parent scope.\nUpdates <code>self.mapping</code> with the desired entry. Creates a new …\nA <code>Replacer</code> applies <code>replacer</code> to all <code>Identifier</code>s in an AST. …\nMaps global and local symbols to information about them.\nLocal tables index by the NodeID of the function, …\nAttach a finalizer to a function.\nThe consts we’ve evaluated in this scope.\nEnter the parent scope of the current scope (or the global …\nEnter the scope of this <code>NodeID</code>, creating a table if it …\nEnter the new scope with id <code>new_id</code>, duplicating its local …\nReturns the argument unchanged.\nReturns the argument unchanged.\nFunctions indexed by location.\nConsts that have been successfully evaluated.\nGlobal variables indexed by location.\nThe <code>NodeID</code> of the function, iteration, or block this table …\nInsert an evaluated const into the current scope.\nInsert a function at this location.\nInsert a global at this location.\nInsert a record at this location.\nInsert a struct at this name.\nInsert a variable into the current scope.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIterator over all the functions in this program.\nIterator over all the records in this program.\nIterator over all the structs (not records) in this …\nThe current LocalTable we’re looking at.\nFind the evaluated const accessible by the given name in …\nAccess the function at this location if it exists.\nAccess the global at this location if it exists.\nAccess the record at this location if it exists.\nAccess the struct by this name if it exists.\nAccess the variable accessible by this name in the current …\nThe parent <code>NodeID</code> of this scope, if it exists.\nRecords indexed by location.\nStructs indexed by location.\nVariables in this scope, indexed by name.\nAn entry for a variable in the symbol table.\nAn enumeration of the different types of variable type.\nThe type of declaration for the variable.\nThe locations of the futures passed to the async function …\nThe types passed to the async function called by this …\nThe name of the async function this async transition calls.\nThe <code>Span</code> associated with the variable.\nThe <code>Type</code> of the variable.\nA binary search tree to store all paths through nested …\nA node in a graph.\nA node in a tree.\nA counter.\nA counter.\nAdds a child to the current node.\nThe current depth.\nThe current depth.\nThe current node.\nThe current node.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nInitializes a new <code>TreeNode</code> from a vector of starting …\nRemoves an element from the current node. If the element …\nA mapping between node IDs and their types.\nGets an entry from the table.\nThe inner table. <code>RefCell</code> is used here to avoid <code>&amp;mut</code> all …\nInserts an entry into the table.\nA pass to perform const propagation and folding.\nAn array index which was not able to be evaluated.\nAn array length which was not able to be evaluated.\nSomething about the program was actually changed during …\nA const declaration whose RHS was not able to be evaluated.\nA repeat expression count which was not able to be …\nAn array index which was not able to be evaluated.\nAn array length which was not able to be evaluated.\nHave we actually modified the program at all?\nThe RHS of a const declaration we were not able to …\nEmit a <code>StaticAnalyzerError</code>.\nReturns the argument unchanged.\nEnter the symbol table’s scope <code>id</code>, execute <code>func</code>, and …\nCalls <code>U::from(self)</code>.\nThe program name.\nA repeat expression count which was not able to be …\nPass that runs const propagation and loop unrolling until …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe name of the program currently being processed.\nReconstruct an assignment statement by eliminating any …\nReconstructs the statements inside a basic block, …\nStatic single assignment replaces definition statements …\nLoop unrolling unrolls and removes iteration statements …\nHow many statements were in the AST after DCE?\nHow many statements were in the AST before DCE?\nThe set of used variables in the current function body.\nA pass to rewrite tuple creation and accesses into other …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWhether or not we are currently traversing an async …\nModify assignments to tuples to become assignments to the …\nSimilar to <code>reconstruct_expression</code>, except that if …\nIf this is a ternary expression on tuples of length <code>n</code>, we…\nReplaces a tuple access expression with the appropriate …\nA mapping between variables and tuple elements.\nA Constructed guard is one which as been <code>And</code>ed with all …\nThere was a chain of conditionals on the path to this …\nAn expression representing a conditional to reach the …\nThere were no conditionals on the path to this return …\nAn Unconstructed guard is one representing a single …\nThere was a chain of conditionals on the path to this …\nA stack of condition <code>Expression</code>s visited up to the current …\nConstruct an early return guard.\nConstruct a guard from the current state of the condition …\nFold guards and expressions into a single expression. Note …\nFolds a list of return statements into a single return …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether the function is an async function.\nThe program name.\nRewrites an assert statement into a flattened form. Assert …\nFlattens the statements inside a basic block. The …\nFlatten a conditional statement into a list of statements.\nFlattens a definition, if necessary. Marks variables as …\nFlattens a function’s body\nFlattens a program scope.\nTransforms a return statement into an empty block …\nReconstructs a struct init expression, flattening any …\nReconstructs ternary expressions over arrays, structs, and …\nA list containing tuples of guards and expressions …\nA wrapper around <code>assigner.simple_definition</code> that tracks …\nA wrapper around <code>assigner.unique_simple_definition</code> that …\nTrue iff any of the guards to return statements so far …\nTrue iff the conditionals on the path to this return …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWhether or not we are currently traversing an async …\nThe main program.\nReconstructs the statements inside a basic block, …\nFlattening removes conditional statements from the program.\nReconstruct a definition statement by inlining any …\nReconstructs expression statements by inlining any …\nLoop unrolling unrolls and removes iteration statements …\nA map of reconstructed functions in the current program …\nIf we encountered a loop that was not unrolled, here’s it…\nDid we unroll any loop?\nDuplicate this block, recursively giving new <code>NodeID</code>s into …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWhether or not a bound is inclusive or exclusive.\nA trait for whose implementors are concrete values for …\nAn iterator over a range of values.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEmits a Loop Unrolling Error\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIf we’ve encountered a loop that was not unrolled, here…\nHave we unrolled any loop?\nThe current program name.\nUnrolls an IterationStatement.\nA helper function to unroll a single iteration an …\nDid we change anything in this program?\nIf we encountered calls to const generic functions that …\nIf we encountered const generic struct expressions that …\nIf we encountered const generic struct type instantiations …\nHave we actually modified the program at all?\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMonomorphizes a generic struct by substituting const …\nA set of all functions that have been monomorphized at …\nA set of all functions that have been monomorphized at …\nThe main program.\nA map of reconstructed functions in the current program …\nA map of reconstructed functions in the current program …\nA vector of all the calls to const generic functions that …\nA vector of all the struct expressions of const generic …\nA vector of all the struct type instantiations of const …\nContains data share by many compiler passes.\nA compiler pass.\nCreates unique symbols and definitions.\nThe Abstract Syntax Tree.\nA graph of which functions call each other.\nRuns the compiler pass.\nThe error Handler.\nIs this a test program?\nCreates incrementing node IDs.\nA graph of which structs refer to each other.\nContains data about the variables and other entities in …\nMaps node IDs to types.\nA set of the warnings collected. This is used to make sure …\nA pass to validate (and remove) uses of <code>interpret</code>.\nThe variant of the function we are currently traversing.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEnter scope for <code>then</code> branch of conditional.\nExit scope for conditional statement at current depth.\nExit scope for <code>then</code> branch of conditional.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nInitializes a new <code>AwaitChecker</code>.\nRemove from list. Returns <code>true</code> if there was a path where …\nInitialize futures.\nStatically updated set of futures to await.\nAll possible subsets of futures that must be awaited.\nReturns the argument unchanged.\nReturns the argument unchanged.\nError if futures are used improperly.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nType checks the awaiting of a future.\nAssert that an async call is a “simple” one. Simple is …\nStruct to store the state relevant to checking all futures …\nThe current program name.\nEmits a type checker warning\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWhether or not a non-async external call has been seen in …\nThe variant of the function that we are currently …\nConsumes an array expression, accumulating any statements …\nConsumes the expressions in an <code>AssertStatement</code>, returning …\nConsume all <code>AssignStatement</code>s, renaming as necessary.\nConsumes a binary expression, accumulating any statements …\nConsumes a <code>Block</code>, flattening its constituent …\nConsumes a call expression without visiting the function …\nConsumes a cast expression, accumulating any statements …\nConsumes a <code>ConditionalStatement</code>, producing phi functions …\nConsumes the <code>DefinitionStatement</code> into an <code>AssignStatement</code>, …\nConsume this expression and assign it to a variable …\nConsumes the expressions associated with …\nReconstructs the <code>Function</code>s in the <code>Program</code>, while …\nRetrieve the new name for this <code>Identifier</code>.\nConsumes and returns the literal without making any …\nConsumes and returns the locator expression without making …\nReconstructs the expression associated with the return …\nReconstructs records in the program, ordering its fields …\nConsumes a struct initialization expression with renamed …\nConsumes a ternary expression, accumulating any statements …\nConsumes a tuple expression, accumulating any statements …\nConsumes a unary expression, accumulating any statements …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIf the RenameTable has a parent, then <code>self.rename_table</code> is …\nThe main program name.\nPushes a new scope, setting the current scope as the new …\nWhether to rename places in definitions.\nThe <code>RenameTable</code> for the current basic block in the AST\nConstructs a simple assign statement for <code>expr</code> with a …\nA pass to fill the SymbolTable.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWhether or not traversing stub.\nThe current program name.\nThe state of the compiler.\nThe set of local structs that have been successfully …\nA pass to check types.\nSpecify network limits for type checking.\nLocation of most recent external call that produced a …\nReturns the argument unchanged.\nThe name of the function that we are currently traversing.\nThe futures that must be propagated to an async function.\nWhether the finalize caller has called the finalize …\nWhether or not the function that we are currently …\nInitialize state variables for new function.\nCalls <code>U::from(self)</code>.\nWhether the current function is a call.\nWhether currently traversing a conditional statement.\nWhether or not we are currently traversing a stub.\nGet the current location.\nInitializes a new <code>ScopeState</code>.\nCurrent program name.\nThe variant of the function that we are currently …\nUse this method when you know the actual type. Emits an …\nEmits an error if the type is not a mapping.\nEmits an error if the struct member is a record type.\nEmits an error if the type or its constituent types is not …\nMapping from async function name to the names of async …\nMapping from async function stub name to the inferred …\nType checks the inputs to a core function call and returns …\nEmits an error if the two given types are not equal.\nHelper function to check that the input and output of …\nFor detecting the error …\nEmits a type checker error.\nEmits a type checker warning\nAre the types considered equal as far as the Leo user is …\nReturns the argument unchanged.\nType checks the inputs to an associated constant and …\nEmits an error if the <code>struct</code> is not a core library struct. …\nInserts variable to symbol table.\nCalls <code>U::from(self)</code>.\nSo we can check if we exceed limits on array size, number …\nWrapper around lookup_struct that additionally records all …\nMerge inferred types into <code>lhs</code>.\nThe state of the current scope being traversed.\nThe set of used composites.\nInfers the type of an expression, and if it is …\nInfers the type of an expression, but returns Type::Err …\nA pass to rewrite assignments to array accesses and struct …\nThis visitor associates a variable for each member of a …\nFind assignments to arrays and structs and populate …\nFor any array whose members are written to, a vec …\nIf <code>name</code> is a struct or array whose members are written to, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis is the only reconstructing function where we do …\nIf we’re assigning to a struct or array member, find the …\nIf we’re assigning to a struct or array, create …\nFor any struct whose members are written to, a map of its …")