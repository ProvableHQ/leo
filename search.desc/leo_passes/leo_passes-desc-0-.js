searchState.loadedDescShard("leo_passes", 0, "leo-passes\nA pass to perform const propagation and folding.\nAn array index which was not able to be evaluated.\nAn array index which was not able to be evaluated.\nHave we actually modified the progam at all?\nSomething about the program was actually changed during …\nThe RHS of a const declaration we were not able to …\nA const declaration whose RHS was not able to be evaluated.\nThe Dead Code Elimination pass traverses the AST and …\nThe destructuring pass traverses the AST and destructures …\nRuns the compiler pass.\nThe flattening pass traverses the AST after the SSA pass …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe Function Inlining pass traverses the AST and inlines …\nThe error handler.\nThe error handler.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether or not traversing stub.\nA counter used to generate unique node IDs.\nThe program name.\nThe current program name.\nThe Static Single Assignment pass traverses the AST and …\nThe set of local structs that have been successfully …\nThe symbol table associated with the program.\nThe <code>SymbolTable</code> constructed by this compiler pass.\nA mapping between node IDs and their types.\nThe call graph for the program.\nMapping of composite names to a tuple containing metadata …\nThe depth of the current conditional block.\nReference to the current function.\nA reference to the finalize caller.\nReturns the argument unchanged.\nMapping of global identifiers to their associated names.\nCalls <code>U::from(self)</code>.\nInitializes a new <code>CodeGenerator</code>.\nA counter to track the next available label.\nA counter to track the next available register.\nA reference to program. This is needed to look up external …\nThe program ID of the current program.\nThe struct dependency graph for the program.\nThe symbol table for the program.\nA mapping between expressions and their types.\nMapping of variables to registers.\nThe variant of the function we are currently traversing.\nA struct used to create assignment statements.\nContains the actual data for <code>Assigner</code>. Modeled this way to …\nA strictly increasing counter, used to ensure that new …\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe inner counter. <code>RefCell</code> is used here to avoid <code>&amp;mut</code> all …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstructs the assignment statement <code>place = expr;</code>. This …\nConstructs the assignment statement <code>place = expr;</code>. This …\nReturn a new unique <code>Symbol</code> from a <code>&amp;str</code>.\nReturn a new unique <code>Symbol</code> from a <code>&amp;str</code>.\nA call graph.\nAn error that is emitted when a cycle is detected in the …\nA directed graph.\nErrors in directed graph operations.\nAn import dependency graph.\nA node in a graph.\nA struct dependency graph.\nAdds an edge to the graph.\nReturns <code>true</code> if the graph contains the given node.\nThe directed edges in the graph. Each entry in the map is …\nThe directed edges in the graph. Each entry in the map is …\nThe directed edges in the graph. Each entry in the map is …\nThe directed edges in the graph. Each entry in the map is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInitializes a new <code>DiGraph</code> from a vector of source nodes.\nThe set of nodes in the graph.\nThe set of nodes in the graph.\nThe set of nodes in the graph.\nThe set of nodes in the graph.\nReturns the post-order ordering of the graph. Detects if …\nRetains a subset of the nodes, and removes all edges in …\n<code>RenameTable</code> tracks the names assigned by static single …\nReturns the argument unchanged.\nThe mapping from symbols to node IDs. These are used to …\nCalls <code>U::from(self)</code>.\nReturns the symbols that were renamed in the current scope.\nLooks up the new name for <code>symbol</code>, recursively checking the …\nLooks up the node ID for <code>symbol</code>, recursively checking the …\nThe mapping from names in the original AST to new names in …\nCreate a new <code>RenameTable</code> with the given parent.\nThe <code>RenameTable</code> of the parent scope.\nUpdates <code>self.mapping</code> with the desired entry. Creates a new …\nA <code>Replacer</code> applies <code>replacer</code> to all <code>Identifier</code>s in an AST. …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMaps global and local symbols to information about them.\nAn entry for a variable in the symbol table.\nAn enumeration of the different types of variable type.\nLocal tables index by the NodeID of the function, …\nAttach a finalizer to a function.\nThe consts we’ve evaluated in this scope.\nThe type of declaration for the variable.\nEnther the parent scope of the current scope (or the …\nEnter the scope of this <code>NodeID</code>, creating a table if it …\nEnter the new scope with id <code>new_id</code>, duplicating its local …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFunctions indexed by location.\nThe locations of the futures passed to the async function …\nConsts that have been successfully evaluated.\nGlobal variables indexed by location.\nThe <code>NodeID</code> of the function, iteration, or block this table …\nThe types passed to the async function called by this …\nInsert an evaluated const into the current scope.\nInsert a function at this location.\nInsert a global at this location.\nInsert a record at this location.\nInsert a struct at this name.\nInsert a variable into the current scope.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIterator over all the functions in this program.\nIterator over all the records in this program.\nIterator over all the structs (not records) in this …\nThe current LocalTable we’re looking at.\nThe name of the async function this async transition calls.\nFind the evaluated const accessible by the given name in …\nAccess the function at this location if it exists.\nAccess the global at this location if it exists.\nAccess the record at this location if it exists.\nAccess the struct by this name if it exists.\nAccess the variable accessible by this name in the current …\nThe parent <code>NodeID</code> of this scope, if it exists.\nRecords indexed by location.\nThe <code>Span</code> associated with the variable.\nStructs indexed by location.\nThe <code>Type</code> of the variable.\nVariables in this scope, indexed by name.\nAn entry for a variable in the symbol table.\nAn enumeration of the different types of variable type.\nThe type of declaration for the variable.\nThe locations of the futures passed to the async function …\nThe types passed to the async function called by this …\nThe name of the async function this async transition calls.\nThe <code>Span</code> associated with the variable.\nThe <code>Type</code> of the variable.\nA binary search tree to store all paths through nested …\nA node in a graph.\nA node in a tree.\nA counter.\nA counter.\nAdds a child to the current node.\nThe current depth.\nThe current depth.\nThe current node.\nThe current node.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nInitializes a new <code>TreeNode</code> from a vector of starting …\nRemoves an element from the current node. If the element …\nA mapping between node IDs and their types.\nReturns the argument unchanged.\nGets an entry from the table.\nThe inner table. <code>RefCell</code> is used here to avoid <code>&amp;mut</code> all …\nInserts an entry into the table.\nCalls <code>U::from(self)</code>.\nAn array index which was not able to be evaluated.\nSomething about the program was actually changed during …\nA const declaration whose RHS was not able to be evaluated.\nA pass to perform const propagation and folding.\nAn array index which was not able to be evaluated.\nHave we actually modified the progam at all?\nThe RHS of a const declaration we were not able to …\nEmit a <code>StaticAnalyzerError</code>.\nThe error handler.\nEnter the symbol table’s scope <code>id</code>, execute <code>func</code>, and …\nA counter used to generate unique node IDs.\nThe program name.\nThe symbol table associated with the program.\nA mapping between node IDs and their types.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWhether or not we are currently traversing an async …\nWhether or not the variables are necessary.\nInitializes a new <code>DeadCodeEliminator</code>.\nA counter to generate unique node IDs.\nReconstruct an assignment statement by eliminating any …\nReconstructs the associated function access expression.\nReconstructs the statements inside a basic block, …\nFlattening removes conditional statements from the program.\nParsing guarantees that console statements are not present …\nStatic single assignment replaces definition statements …\nReconstructs expression statements by eliminating any dead …\nMarks identifiers as used. This is necessary to determine …\nLoop unrolling unrolls and removes iteration statements …\nReconstruct the components of the struct init expression. …\nThe set of used variables in the current function body.\nA struct used to construct (unique) assignment statements.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWhether or not we are currently traversing an async …\nA counter used to generate unique node IDs.\nFlattens an assign statement, if necessary. Marks …\nReconstructs\nReplaces a tuple access expression with the appropriate …\nA wrapper around <code>assigner.simple_assign_statement</code> that …\nA mapping between variables and flattened tuple …\nA mapping between node IDs and their types.\nA Constructed guard is one which as been <code>And</code>ed with all …\nThere was a chain of conditionals on the path to this …\nAn expression representing a conditional to reach the …\nThere were no conditionals on the path to this return …\nAn Unconstructed guard is one representing a single …\nThere was a chain of conditionals on the path to this …\nA struct used to construct (unique) assignment statements.\nA stack of condition <code>Expression</code>s visited up to the current …\nConstruct an early return guard.\nConstruct a guard from the current state of the condition …\nFold guards and expressions into a single expression. Note …\nFolds a list of return statements into a single return …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether the function is an async function.\nA counter used to generate unique node IDs.\nThe program name.\nRewrites an assert statement into a flattened form. Assert …\nFlattens an assign statement, if necessary. Marks …\nFlattens the statements inside a basic block. The …\nFlatten a conditional statement into a list of statements.\nFlattens a function’s body\nFlattens a program scope.\nTransforms a return statement into an empty block …\nReconstructs a struct init expression, flattening any …\nReconstructs ternary expressions over arrays, structs, and …\nA list containing tuples of guards and expressions …\nA wrapper around <code>assigner.simple_assign_statement</code> that …\nThe symbol table associated with the program.\nA mapping between node IDs and their types.\nA wrapper around <code>assigner.unique_simple_assign_statement</code> …\nTrue iff any of the guards to return statements so far …\nTrue iff the conditionals on the path to this return …\nAn <code>AssignmentRenamer</code> renames the left-hand side of all …\nClear the internal rename table.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nLoad the internal rename table with a set of entries.\nInitialize a new <code>AssignmentRenamer</code>.\nRename the left-hand side of the assignment statement.\nFlattening removes conditional statements from the program.\nParsing guarantees that console statements are not present …\nStatic single assignment replaces definition statements …\nRename the identifier if it is the left-hand side of an …\nLoop unrolling unrolls and removes iteration statements …\nRename the variable initializers in the struct expression.\nA wrapper around an Assigner used to create unique …\nThe call graph for the program.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWhether or not we are currently traversing an async …\nInitializes a new <code>FunctionInliner</code>.\nA counter used to create unique NodeIDs.\nThe main program.\nReconstruct an assignment statement by inlining any …\nReconstructs the statements inside a basic block, …\nFlattening removes conditional statements from the program.\nParsing guarantees that console statements are not present …\nStatic single assignment replaces definition statements …\nReconstructs expression statements by inlining any …\nLoop unrolling unrolls and removes iteration statements …\nA map of reconstructed functions in the current program …\nA mapping between node IDs and their types.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIf we encountered a loop that was not unrolled, here’s it…\nDid we unroll any loop?\nDuplicate this block, recursively giving new <code>NodeID</code>s into …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWhether or not a bound is inclusive or exclusive.\nA trait for whose implementors are concrete values for …\nAn iterator over a range of values.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe current program name.\nEmits a Loop Unrolling Error\nReturns the argument unchanged.\nAn error handler used for any errors found during …\nCalls <code>U::from(self)</code>.\nAre we in the midst of unrolling a loop?\nIf we’ve encountered a loop that was not unrolled, here…\nHave we unrolled any loop?\nA counter used to generate unique node IDs.\nThe symbol table for the function being processed.\nA mapping from node IDs to their types.\nUnrolls an IterationStatement.\nA helper function to unroll a single iteration an …\nA compiler pass consuming <code>Self::Input</code> and returning …\nRuns the compiler pass.\nType checks the awaiting of a future.\nAssert that an async call is a “simple” one. Simple is …\nStruct to store the state relevant to checking all futures …\nThe current program name.\nEmits a type checker error.\nEmits a type checker warning\nReturns the argument unchanged.\nThe error handler.\nCalls <code>U::from(self)</code>.\nReturns a new static analyzer given a symbol table and …\nWhether or not a non-async external call has been seen in …\nThe symbol table for the program.\nThe type table for the program.\nThe variant of the function that we are currently …\nEnter scope for <code>then</code> branch of conditional.\nWhether or not to do full tree search for await checking.\nExit scope for conditional statement at current depth.\nExit scope for <code>then</code> branch of conditional.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMaximum nesting depth to search for await checking.\nInitializes a new <code>AwaitChecker</code>.\nRemove from list. Returns <code>true</code> if there was a path where …\nInitialize futures.\nStatically updated set of futures to await.\nAll possible subsets of futures that must be awaited.\nReturns the argument unchanged.\nReturns the argument unchanged.\nError if futures are used improperly.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA struct used to construct (unique) assignment statements.\nConsumes an access expression, accumulating any statements …\nConsumes an array expression, accumulating any statements …\nConsumes the expressions in an <code>AssertStatement</code>, returning …\nConsume all <code>AssignStatement</code>s, renaming as necessary.\nConsumes a binary expression, accumulating any statements …\nConsumes a <code>Block</code>, flattening its constituent …\nConsumes a call expression without visiting the function …\nConsumes a cast expression, accumulating any statements …\nConsumes a <code>ConditionalStatement</code>, producing phi functions …\nParsing guarantees that console statements are not present …\nConsumes the <code>DefinitionStatement</code> into an <code>AssignStatement</code>, …\nConsumes the expressions associated with …\nReconstructs the <code>Function</code>s in the <code>Program</code>, while …\nProduces a new <code>Identifier</code> with a unique name.\nConsumes and returns the literal without making any …\nConsumes and returns the locator expression without making …\nReconstructs the expression associated with the return …\nReconstructs records in the program, ordering its fields …\nConsumes a struct initialization expression with renamed …\nConsumes a ternary expression, accumulating any statements …\nConsumes a tuple expression, accumulating any statements …\nConsumes a unary expression, accumulating any statements …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA flag to determine whether or not the traversal is on the …\nInitializes a new <code>StaticSingleAssigner</code> with an empty …\nA counter used to generate unique node IDs.\nIf the RenameTable has a parent, then <code>self.rename_table</code> is …\nThe main program name.\nPushes a new scope, setting the current scope as the new …\nThe <code>RenameTable</code> for the current basic block in the AST\nThe <code>SymbolTable</code> of the program.\nA mapping from node IDs to their types.\nConstructs a simple assign statement for <code>expr</code> with a …\nThe error handler.\nWhether or not traversing stub.\nThe current program name.\nThe set of local structs that have been successfully …\nThe <code>SymbolTable</code> constructed by this compiler pass.\nUse this method when you know the actual type. Emits an …\nEmits an error if the type is not a mapping.\nEmits an error if the struct member is a record type.\nEmits an error if the type or its constituent types is not …\nMapping from async function name to the names of async …\nMapping from async function stub name to the inferred …\nThe call graph for the program.\nType checks the inputs to a core function call and returns …\nEmits an error if the two given types are not equal.\nHelper function to check that the input and output of …\nFor detecting the error …\nEmits a type checker error.\nEmits a type checker warning\nAre the types considered equal as far as the Leo user is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nType checks the inputs to an associated constant and …\nEmits an error if the <code>struct</code> is not a core library struct. …\nThe error handler.\nInserts variable to symbol table.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSo we can check if we exceed limits on array size, number …\nWrapper around lookup_struct that additionally records all …\nMerge inferred types into <code>lhs</code>.\nReturns a new type checker given a symbol table and error …\nThe state of the current scope being traversed.\nA dependency graph of the structs in program.\nThe symbol table for the program.\nA mapping from node IDs to their types.\nThe set of used composites.\nLocation of most recent external call that produced a …\nReturns the argument unchanged.\nThe name of the function that we are currently traversing.\nThe futures that must be propagated to an async function.\nWhether the finalize caller has called the finalize …\nWhether or not the function that we are currently …\nInitialize state variables for new function.\nCalls <code>U::from(self)</code>.\nWhether the current function is a call.\nWhether currently traversing a conditional statement.\nWhether or not we are currently traversing a stub.\nGet the current location.\nInitializes a new <code>ScopeState</code>.\nCurrent program name.\nThe variant of the function that we are currently …")