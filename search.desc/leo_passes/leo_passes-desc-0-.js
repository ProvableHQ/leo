searchState.loadedDescShard("leo_passes", 0, "leo-passes\nA struct used to create assignment statements.\nContains the actual data for <code>Assigner</code>. Modeled this way to …\nContains data shared by many compiler passes.\nA binary search tree to store all paths through nested …\nPass that runs const propagation, loop unrolling, and …\nA pass to perform const propagation and folding.\nA pass to rewrite tuple creation and accesses into other …\nA compiler pass.\nA pass to validate (and remove) uses of <code>interpret</code>.\n<code>RenameTable</code> tracks the names assigned by static single …\nA <code>Replacer</code> traverses and reconstructs the AST, applying a …\nMaps global and local symbols to information about them.\nA pass to fill the SymbolTable.\nA pass to check types.\nSpecify network limits for type checking.\nA mapping between node IDs and their types.\nAn entry for a variable in the symbol table.\nAn enumeration of the different types of variable type.\nA pass to rewrite assignments to array accesses and struct …\nLocal tables index by the NodeID of the function, …\nAn array index which was not able to be evaluated.\nAn array index which was not able to be evaluated.\nAn array length which was not able to be evaluated.\nAn array length which was not able to be evaluated.\nCreates unique symbols and definitions.\nThe Abstract Syntax Tree.\nA graph of which functions call each other.\nHave we actually modified the program at all?\nSomething about the program was actually changed during …\nDid we change anything in this program?\nThe common subexpression elimination pass traverses the …\nThe RHS of a const declaration we were not able to …\nA const declaration whose RHS was not able to be evaluated.\nA counter.\nA strictly increasing counter, used to ensure that new …\nThe Dead Code Elimination pass traverses the AST and …\nThe type of declaration for the variable.\nThe current depth.\nThe destructuring pass traverses the AST and destructures …\nRuns the compiler pass.\nThe current node.\nThe flattening pass traverses the AST after the SSA pass …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe Function Inlining pass traverses the AST and inlines …\nFunctions indexed by location.\nThe locations of the futures passed to the async function …\nConsts that have been successfully evaluated.\nGlobal variables indexed by location.\nThe error Handler.\nThe mapping from symbols to node IDs. These are used to …\nThe types passed to the async function called by this …\nThe inner counter. <code>RefCell</code> is used here to avoid <code>&amp;mut</code> all …\nThe inner table. <code>RefCell</code> is used here to avoid <code>&amp;mut</code> all …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this a test program?\nThe current LocalTable we’re looking at.\nThe name of the async function this async transition calls.\nIf we encountered a loop that was not unrolled, here’s it…\nDid we unroll any loop?\nThe module name.\nPerforms monomorphization of const generic functions …\nThe mapping from names in the original AST to new names in …\nThe network.\nCreates incrementing node IDs.\nPerforms lowering of <code>optional</code> types (<code>T?</code>) and <code>optional</code> …\nThe <code>RenameTable</code> of the parent scope.\nA transform pass that resolves and reconstructs AST paths …\nThe <code>ProcessingAsync</code> pass rewrites <code>async { ... }</code> blocks …\nThe program name.\nRecords indexed by location.\nA repeat expression count which was not able to be …\nA repeat expression count which was not able to be …\nThe <code>Span</code> associated with the variable.\nThe Static Single Assignment pass traverses the AST and …\nPerforms lowering of <code>storage</code> variables and storage vectors …\nA graph of which structs refer to each other.\nStructs indexed by a path.\nContains data about the variables and other entities in …\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\nThe <code>Type</code> of the variable.\nMaps node IDs to types.\nIf we encountered calls to const generic functions that …\nIf we encountered const generic struct expressions that …\nIf we encountered const generic struct type instantiations …\nA set of the warnings collected. This is used to make sure …\nThis function checks whether the constructor is …\nMapping of composite names to a tuple containing metadata …\nThe depth of the current conditional block.\nReference to the current function.\nA reference to the finalize caller. Because …\nReturns the argument unchanged.\nMapping of global identifiers to their associated names. …\nInternal record input registers of the current function. …\nCalls <code>U::from(self)</code>.\nConverts a path into a legal Aleo identifier, if possible.\nA counter to track the next available label.\nA counter to track the next available register.\nA reference to program. This is needed to look up external …\nThe program ID of the current program.\nMapping of local variables to registers. Because these are …\nThe variant of the function we are currently traversing.\nA struct used to create assignment statements.\nContains the actual data for <code>Assigner</code>. Modeled this way to …\nA strictly increasing counter, used to ensure that new …\nThe inner counter. <code>RefCell</code> is used here to avoid <code>&amp;mut</code> all …\nConstructs the definition statement <code>let place = expr;</code>. …\nConstructs the definition statement <code>let place = expr;</code>. …\nReturn a new unique <code>Symbol</code> from a <code>&amp;str</code>.\nReturn a new unique <code>Symbol</code> from a <code>&amp;str</code>.\n<code>RenameTable</code> tracks the names assigned by static single …\nThe mapping from symbols to node IDs. These are used to …\nReturns the symbols that were renamed in the current scope.\nLooks up the new name for <code>symbol</code>, recursively checking the …\nLooks up the node ID for <code>symbol</code>, recursively checking the …\nThe mapping from names in the original AST to new names in …\nCreate a new <code>RenameTable</code> with the given parent.\nThe <code>RenameTable</code> of the parent scope.\nUpdates <code>self.mapping</code> with the desired entry. Creates a new …\nA <code>Replacer</code> traverses and reconstructs the AST, applying a …\nMaps global and local symbols to information about them.\nLocal tables index by the NodeID of the function, …\nAttach a finalizer to a function.\nThe children of <code>NodeID</code> of this scope\nThe consts we’ve evaluated in this scope.\nCreates a duplicate of this local scope with a new <code>NodeID</code>.\nEnter the parent scope of the current scope (or the global …\nEnter the scope of this <code>NodeID</code>, creating a table if it …\nEnter the new scope with id <code>new_id</code>, duplicating its local …\nReturns the argument unchanged.\nReturns the argument unchanged.\nFunctions indexed by location.\nConsts that have been successfully evaluated.\nAre we currently in the global scope?\nGlobal variables indexed by location.\nThe <code>NodeID</code> of the function, iteration, or block this table …\nInsert an evaluated const into the current scope.\nInsert a function at this location.\nInsert a global at this location.\nInsert a record at this location.\nInsert a struct at this name.\nInsert a variable into the current scope.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks whether <code>symbol</code> is defined in the current scope …\nChecks if a <code>symbol</code> is local to <code>scope</code>.\nChecks if a <code>symbol</code> is local to <code>scope</code> or any of its child …\nIterator over all the functions in this program.\nIterator over all the records in this program.\nIterator over all the structs (not records) in this …\nThe current LocalTable we’re looking at.\nFind the evaluated const accessible by the given name in …\nAccess the function at this location if it exists.\nAccess the global at this location if it exists.\nAccess the variable accessible by this name in the current …\nAttempts to look up a variable by a path.\nAccess the record at this location if it exists.\nAccess the struct by this name if it exists.\nThe parent <code>NodeID</code> of this scope, if it exists.\nRecords indexed by location.\nReset everything except leave global consts that have been …\nStructs indexed by a path.\nVariables in this scope, indexed by name.\nAn entry for a variable in the symbol table.\nAn enumeration of the different types of variable type.\nThe type of declaration for the variable.\nThe locations of the futures passed to the async function …\nThe types passed to the async function called by this …\nThe name of the async function this async transition calls.\nThe <code>Span</code> associated with the variable.\nThe <code>Type</code> of the variable.\nA binary search tree to store all paths through nested …\nA node in a graph.\nA node in a tree.\nA counter.\nA counter.\nAdds a child to the current node.\nThe current depth.\nThe current depth.\nThe current node.\nThe current node.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nInitializes a new <code>TreeNode</code> from a vector of starting …\nRemoves an element from the current node. If the element …\nA mapping between node IDs and their types.\nGets an entry from the table.\nThe inner table. <code>RefCell</code> is used here to avoid <code>&amp;mut</code> all …\nInserts an entry into the table.\nAn atomic expression - path or literal.\nAn expression that can be mapped to a variable, and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTurn <code>expression</code> into an <code>Atom</code> if possible, looking it up in …\nReconstruct the expression, looking it up in the table of …\nPass that runs const propagation, loop unrolling, and …\nA pass to perform const propagation and folding.\nAn array index which was not able to be evaluated.\nAn array length which was not able to be evaluated.\nSomething about the program was actually changed during …\nA const declaration whose RHS was not able to be evaluated.\nA repeat expression count which was not able to be …\nAn array index which was not able to be evaluated.\nAn array length which was not able to be evaluated.\nHave we actually modified the program at all?\nThe RHS of a const declaration we were not able to …\nEmit a <code>StaticAnalyzerError</code>.\nEnter module scope with path <code>module</code>, execute <code>func</code>, and …\nEnter the symbol table’s scope <code>id</code>, execute <code>func</code>, and …\nThe module name.\nThe program name.\nA repeat expression count which was not able to be …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe name of the program currently being processed.\nReconstruct an assignment statement by eliminating any …\nReconstructs the statements inside a basic block, …\nStatic single assignment replaces definition statements …\nLoop unrolling unrolls and removes iteration statements …\nHow many statements were in the AST after DCE?\nHow many statements were in the AST before DCE?\nThe set of used variables in the current function body.\nA pass to rewrite tuple creation and accesses into other …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWhether or not we are currently traversing an async …\nModify assignments to tuples to become assignments to the …\nSimilar to <code>reconstruct_expression</code>, except that if …\nIf this is a ternary expression on tuples of length <code>n</code>, we…\nReplaces a tuple access expression with the appropriate …\nA mapping between variables and tuple elements.\nA Constructed guard is one which as been <code>And</code>ed with all …\nThere was a chain of conditionals on the path to this …\nAn expression representing a conditional to reach the …\nThere were no conditionals on the path to this return …\nAn Unconstructed guard is one representing a single …\nThere was a chain of conditionals on the path to this …\nA stack of condition <code>Expression</code>s visited up to the current …\nConstruct an early return guard.\nConstruct a guard from the current state of the condition …\nFold guards and expressions into a single expression. Note …\nFolds a list of return statements into a single return …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether the function is an async function.\nThe program name.\nRewrites an assert statement into a flattened form. Assert …\nFlattens the statements inside a basic block. The …\nFlatten a conditional statement into a list of statements.\nFlattens a constructor’s body.\nFlattens a definition, if necessary. Marks variables as …\nFlattens a function’s body\nFlattens a program scope.\nTransforms a return statement into an empty block …\nReconstructs a struct init expression, flattening any …\nReconstructs ternary expressions over arrays, structs, and …\nA list containing tuples of guards and expressions …\nA wrapper around <code>assigner.simple_definition</code> that tracks …\nA wrapper around <code>assigner.unique_simple_definition</code> that …\nTrue iff any of the guards to return statements so far …\nTrue iff the conditionals on the path to this return …\nReturns the argument unchanged.\nA map to provide faster lookup of functions.\nCalls <code>U::from(self)</code>.\nWhether or not we are currently traversing an async …\nThe main program.\nReconstructs the statements inside a basic block, …\nFlattening removes conditional statements from the program.\nReconstruct a definition statement by inlining any …\nReconstructs expression statements by inlining any …\nLoop unrolling unrolls and removes iteration statements …\nA map of reconstructed functions in the current program …\nIf we encountered a loop that was not unrolled, here’s it…\nDid we unroll any loop?\nDuplicate this block, recursively giving new <code>NodeID</code>s into …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEmits a Loop Unrolling Error\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIf we’ve encountered a loop that was not unrolled, here…\nHave we unrolled any loop?\nThe current program name.\nUnrolls an IterationStatement.\nA helper function to unroll a single iteration an …\nDid we change anything in this program?\nIf we encountered calls to const generic functions that …\nIf we encountered const generic struct expressions that …\nIf we encountered const generic struct type instantiations …\nHave we actually modified the program at all?\nReturns the argument unchanged.\nA map to provide faster lookup of functions.\nCalls <code>U::from(self)</code>.\nMonomorphizes a generic struct by substituting const …\nA set of all functions that have been monomorphized at …\nA set of all functions that have been monomorphized at …\nThe main program.\nA map of reconstructed functions in the current program …\nA map of reconstructed functions in the current program …\nA map to provide faster lookup of structs.\nEvaluates the given constant arguments if possible.\nA vector of all the calls to const generic functions that …\nA vector of all the struct expressions of const generic …\nA vector of all the struct type instantiations of const …\nReturns the argument unchanged.\nEnter module scope with path <code>module</code>, execute <code>func</code>, and …\nInserts (or reuses) a compiler-generated struct …\nCalls <code>U::from(self)</code>.\nConstructs an <code>Optional&lt;T&gt;</code>-like struct representing <code>None</code> …\nWraps an expression of a given type in an <code>Optional&lt;T&gt;</code>-like …\nContains data shared by many compiler passes.\nA compiler pass.\nCreates unique symbols and definitions.\nThe Abstract Syntax Tree.\nA graph of which functions call each other.\nRuns the compiler pass.\nThe error Handler.\nIs this a test program?\nThe network.\nCreates incrementing node IDs.\nA graph of which structs refer to each other.\nContains data about the variables and other entities in …\nMaps node IDs to types.\nA set of the warnings collected. This is used to make sure …\nReturns the argument unchanged.\nEnter module scope with path <code>module</code>, execute <code>func</code>, and …\nCalls <code>U::from(self)</code>.\nThe current module.\nCollects all symbol accesses within an async block, …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe name of the current function being processed\nThe name of the current program being processed\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe maximum number of inputs allowed for a function. This …\nIndicates whether this pass actually processed any async …\nA map of reconstructed functions in the current program …\nTransforms an <code>AsyncExpression</code> into a standalone async …\nReconstructs a <code>ProgramScope</code> by rewriting all contained …\nA pass to validate (and remove) uses of <code>interpret</code>.\nThe variant of the function we are currently traversing.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEnter scope for <code>then</code> branch of conditional.\nExit scope for conditional statement at current depth.\nExit scope for <code>then</code> branch of conditional.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nInitializes a new <code>AwaitChecker</code>.\nRemove from list. Returns <code>true</code> if there was a path where …\nInitialize futures.\nStatically updated set of futures to await.\nAll possible subsets of futures that must be awaited.\nReturns the argument unchanged.\nReturns the argument unchanged.\nError if futures are used improperly.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nType checks the awaiting of a future.\nAssert that an async call is a “simple” one. Simple is …\nStruct to store the state relevant to checking all futures …\nThe current program name.\nEmits a type checker warning\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWhether or not a non-async external call has been seen in …\nThe variant of the function that we are currently …\nConsumes an array expression, accumulating any statements …\nConsumes the expressions in an <code>AssertStatement</code>, returning …\nConsume all <code>AssignStatement</code>s, renaming as necessary.\nConsumes a binary expression, accumulating any statements …\nConsumes a <code>Block</code>, flattening its constituent …\nConsumes a call expression without visiting the function …\nConsumes a cast expression, accumulating any statements …\nConsumes a <code>ConditionalStatement</code>, producing phi functions …\nReconstructs the <code>Constructor</code> in the <code>Program</code>, while …\nConsumes the <code>DefinitionStatement</code> into an <code>AssignStatement</code>, …\nConsume this expression and assign it to a variable …\nConsumes the expressions associated with …\nReconstructs the <code>Function</code>s in the <code>Program</code>, while …\nConsumes and returns the literal without making any …\nConsumes and returns the locator expression without making …\nRetrieve the new name for this <code>Identifier</code>.\nReconstructs the expression associated with the return …\nReconstructs records in the program, ordering its fields …\nConsumes a struct initialization expression with renamed …\nConsumes a ternary expression, accumulating any statements …\nConsumes a tuple expression, accumulating any statements …\nConsumes a unary expression, accumulating any statements …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIf the RenameTable has a parent, then <code>self.rename_table</code> is …\nThe main program name.\nPushes a new scope, setting the current scope as the new …\nWhether to rename places in definitions.\nThe <code>RenameTable</code> for the current basic block in the AST\nConstructs a simple assign statement for <code>expr</code> with a …\nGenerates a binary expression\nReturns the argument unchanged.\nGenerate mapping names for a vector expression. Each …\nGenerates <code>Mapping::get(path_expr, key_expr)</code>\nGenerates …\nGenerates <code>Mapping::get_or_use(len_path_expr, false, 0u32)</code>\nCalls <code>U::from(self)</code>.\nStandard literal expressions used frequently\nGenerates <code>Mapping::set(path_expr, key_expr, value_expr)</code>\nCreates a path expression from a symbol\nGenerates a ternary expression\nProduces a zero expression for <code>Type</code> <code>ty</code>.\nA pass to fill the SymbolTable.\nReturns the argument unchanged.\nEnter module scope with path <code>module</code>, execute <code>func</code>, and …\nCalls <code>U::from(self)</code>.\nWhether or not traversing stub.\nThe current module name.\nThe current program name.\nThe state of the compiler.\nThe set of local structs that have been successfully …\nA pass to check types.\nSpecify network limits for type checking.\nCreate a new <code>TypeCheckingInput</code> from the given network.\nWhether this function already contains an <code>async</code> block.\nLocation of most recent external call that produced a …\nReturns the argument unchanged.\nThe name of the function that we are currently traversing.\nThe futures that must be propagated to an async function. …\nWhether the finalize caller has called the finalize …\nWhether or not the function that we are currently …\nCalls <code>U::from(self)</code>.\nWhether we are currently traversing a conditional …\nWhether we are currently traversing a constructor.\nWhether or not we are currently traversing a stub.\nGet the current location.\nCurrent module name.\nInitializes a new <code>ScopeState</code>.\nCurrent program name.\nResets the scope state to a valid starting state, before …\nThe variant of the function that we are currently …\nUse this method when you know the actual type. Emits an …\nEmits an error if the type is not a mapping.\nEmits an error if the struct member is a record type.\nEmits an error if the type is not an optional.\nEnsures the given type is valid for use in storage. Emits …\nEmits an error if the type or its constituent types is not …\nEmits an error if the type is not a vector or a mapping.\nEmits an error if the type is not a vector\nIf we’re inside an async block, this is the node ID of …\nMapping from async function name to the names of async …\nMapping from async function stub name to the inferred …\nType checks the inputs to a core function call and returns …\nEmits an error if the two given types are not equal.\nHelper function to check that the input and output of …\nFor detecting the error …\nEmits a type checker error.\nEmits a type checker warning\nReturns the argument unchanged.\nType checks the inputs to an associated constant and …\nEmits an error if the <code>struct</code> is not a core library struct. …\nInserts variable to symbol table.\nCalls <code>U::from(self)</code>.\nSo we can check if we exceed limits on array size, number …\nWrapper around lookup_struct that additionally records all …\nMerge inferred types into <code>lhs</code>.\nThe state of the current scope being traversed.\nUnwraps an optional type to its inner type for use with …\nThe set of used composites.\nInfers the type of an expression, and if it is …\nInfers the type of an expression, but returns Type::Err …\nWraps a type in Optional if the destination type is …\nA pass to rewrite assignments to array accesses and struct …\nThis visitor associates a variable for each member of a …\nFind assignments to arrays and structs and populate …\nFor any array whose members are written to, a vec …\nIf <code>name</code> is a struct or array whose members are written to, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis is the only reconstructing function where we do …\nIf we’re assigning to a struct or array member, find the …\nIf we’re assigning to a struct or array, create …\nFor any struct whose members are written to, a map of its …")