searchState.loadedDescShard("leo_parser", 0, "The parser to convert Leo code text into an [<code>AST</code>] type.\nRepresents all valid Leo keyword tokens. This also …\nCreates a new AST from a given file path and source code …\nThe parser to convert Leo code text into a <code>Program</code> AST …\nThe tokenizer to convert Leo code text into tokens.\nCreates a new program from a given file path and source …\nDummy span used to appease borrow checker.\nStores a program in tokenized format plus additional …\nConstructs a binary expression <code>left op right</code>.\nAdvances the parser cursor by one token.\nChecks whether the current token is <code>tok</code>.\nChecks whether the current token is a <code>Token::Integer(_)</code>.\nTrue if parsing an expression for if and loop statements …\nReturns <code>true</code> if the next token is equal to the given token.\nEats any of the given <code>tokens</code>, returning <code>true</code> if anything …\nEats one of binary operators matching any in <code>tokens</code>.\nAttempts to parse an affine group literal, if present. If …\nEats the next token if it is an identifier and returns it.\nRemoves the next token if it is a [<code>Token::Integer(_)</code>] and …\nEmit the error <code>err</code>.\nEmit the warning <code>warning</code>.\nEats the expected <code>token</code>, or errors.\nEats one of the expected <code>tokens</code>, or errors.\nExpects an <code>Identifier</code>, or errors.\nReturns the argument unchanged.\nHandler used to side-channel emit errors from the parser.\nReturns true if the next token exists.\nCalls <code>U::from(self)</code>.\nLook-ahead <code>dist</code> tokens of <code>self.token</code> and get access to …\nAt the previous token, return and make an identifier with …\nReturns a new <code>ParserContext</code> type given a vector of tokens.\nCounter used to generate unique node ids.\nReturns an <code>Expression</code> AST node if the next tokens …\nReturns an <code>Annotation</code> AST node if the next tokens …\nReturns an <code>Expression</code> AST node if the next tokens …\nReturns an <code>AssertStatement</code> AST node if the next tokens …\nReturns an <code>AssignStatement</code> AST node if the next tokens …\nReturns an <code>Expression</code> AST node if the next tokens …\nParses a left-associative binary expression …\nReturns an <code>Expression</code> AST node if the next tokens …\nReturns an <code>Expression</code> AST node if the next tokens …\nReturns an <code>Expression</code> AST node if the next tokens …\nReturns a <code>Block</code> AST node if the next tokens represent a …\nReturns an <code>Expression</code> AST node if the next tokens …\nReturns an <code>Expression</code> AST node if the next tokens represent\nParse a list separated by <code>,</code> and delimited by brackets.\nReturns an <code>Expression</code> AST node if the next tokens …\nReturns an <code>Expression</code> AST node if the next tokens represent\nReturns a <code>ConditionalStatement</code> AST node if the next tokens …\nReturns a <code>ConsoleStatement</code> AST node if the next tokens …\nReturns a <code>ConstDeclaration</code> AST node if the next tokens …\nReturns a <code>DefinitionStatement</code> AST node if the next tokens …\nReturns an <code>Expression</code> AST node if the next tokens …\nReturns an <code>Expression</code> AST node if the next tokens …\nParses a tuple of <code>Expression</code> AST nodes.\nReturns an <code>Expression</code> AST node if the next token is an …\nParses an external function call <code>credits.aleo/transfer()</code> …\nReturns an [<code>(Identifier, Function)</code>] AST node if the next …\nParses an import statement <code>import foo.leo;</code>.\nReturns an <code>Input</code> AST node if the next tokens represent a …\nParses a list of <code>T</code>s using <code>inner</code> The opening and closing …\nReturns an <code>IterationStatement</code> AST node if the next tokens …\nParses a mapping declaration, e.g. …\nReturns a <code>Member</code> AST node if the next tokens represent a …\nReturns an <code>Expression</code> AST node if the next tokens …\nReturns a [<code>ParamMode</code>] AST node if the next tokens …\nReturns an <code>Expression</code> AST node if the next tokens …\nReturns an <code>Expression</code> AST node if the next tokens …\nReturns an <code>Output</code> AST node if the next tokens represent a …\nParse a list separated by <code>,</code> and delimited by parens.\nReturns an <code>Expression</code> AST node if the next tokens …\nReturns an <code>Expression</code> AST node if the next token is a …\nReturns a [<code>(Type, Span)</code>] tuple of AST nodes if the next …\nReturns a <code>Program</code> AST if all tokens can be consumed and …\nParses a program scope <code>program foo.aleo { ... }</code>.\nReturns a <code>ReturnStatement</code> AST node if the next tokens …\nReturns an <code>Expression</code> AST node if the next tokens …\nReturns a <code>Statement</code> AST node if the next tokens represent …\nParses a struct or record definition, e.g., …\nReturns an <code>Expression</code> AST node if the next tokens …\nReturns a <code>Vec&lt;Member&gt;</code> AST node if the next tokens …\nReturns an <code>Expression</code> AST node if the next tokens represent\nReturns a [<code>(Type, Span)</code>] tuple of AST nodes if the next …\nParses <code>IDENT: TYPE</code>.\nReturns an <code>Expression</code> AST node if the next tokens …\nReturns a reference to the next token if it is a …\nReturns true if the current token is <code>(</code>.\nThe previous token, i.e., if <code>p.tokens = [&#39;3&#39;, *, &#39;4&#39;]</code>, …\nThe name of the program being parsed.\nThe current token, i.e., if <code>p.tokens = [&#39;3&#39;, *, &#39;4&#39;]</code>, then …\nReturns a <code>IntegerType</code> AST node if the given token is a …\nAll un-bumped tokens.\nReturns an unexpected error at the current token.\nCreates a new vector of spanned tokens from a given file …\nYields spanned tokens from the given source code text.\nReturns a dummy token at a dummy span.\nEat an identifier, that is, a string matching ‘[a-zA-Z][…\nEnsure that <code>string</code> contains no Unicode Bidirectional …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nChecks if a char is a Unicode Bidirectional Override code …\n<code>{ ... }</code>\n<code>[ ... ]</code>\nDescribes delimiters of a token sequence.\nRepresents all valid Leo keyword tokens. This also …\n<code>( ... )</code>\nRepresents all valid Leo syntax tokens.\nReturns a tuple: [(token length, token)] if the next token …\nReturns a tuple: [(integer length, integer token)] if an …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the <code>self</code> token equals a Leo keyword.\nConverts <code>self</code> to the corresponding <code>Symbol</code> if it <code>is_keyword</code>.\nReturns the open/close tokens that the delimiter …")