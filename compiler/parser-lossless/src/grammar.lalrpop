
grammar<'a>(handler: &leo_errors::Handler);

use std::iter;

use leo_errors::ParserError;

use crate::tokens::{IdVariants, LalrToken, Token};
use crate::{ExpressionKind, IntegerTypeKind, LiteralKind, StatementKind, SyntaxKind, SyntaxNode, TypeKind};
use crate::check_identifier;

Nonsemantic: SyntaxNode<'a> = {
    Whitespace => SyntaxNode::new_token(SyntaxKind::Whitespace, <>, vec![]),
    Linebreak => SyntaxNode::new_token(SyntaxKind::Linebreak, <>, vec![]),
    CommentLine => SyntaxNode::new_token(SyntaxKind::CommentLine, <>, vec![]),
    CommentBlock => SyntaxNode::new_token(SyntaxKind::CommentBlock, <>, vec![]),
}

NamedPrimitiveType: SyntaxNode<'a> = {
    <name:Bool> <ys:Nonsemantic*> => SyntaxNode::new_token(TypeKind::Boolean.into(), name, ys),
    <name:Address> <ys:Nonsemantic*> => SyntaxNode::new_token(TypeKind::Address.into(), name, ys),
    <name:String> <ys:Nonsemantic*> => SyntaxNode::new_token(TypeKind::String.into(), name, ys),
    <name:Signature> <ys:Nonsemantic*> => SyntaxNode::new_token(TypeKind::Signature.into(), name, ys),
    <name:Field> <ys:Nonsemantic*> => SyntaxNode::new_token(TypeKind::Field.into(), name, ys),
    <name:Group> <ys:Nonsemantic*> => SyntaxNode::new_token(TypeKind::Group.into(), name, ys),
    <name:Scalar> <ys:Nonsemantic*> => SyntaxNode::new_token(TypeKind::Scalar.into(), name, ys),
    <name:U8> <ys:Nonsemantic*> => SyntaxNode::new_token(IntegerTypeKind::U8.into(), name, ys),
    <name:U16> <ys:Nonsemantic*> => SyntaxNode::new_token(IntegerTypeKind::U16.into(), name, ys),
    <name:U32> <ys:Nonsemantic*> => SyntaxNode::new_token(IntegerTypeKind::U32.into(), name, ys),
    <name:U64> <ys:Nonsemantic*> => SyntaxNode::new_token(IntegerTypeKind::U64.into(), name, ys),
    <name:U128> <ys:Nonsemantic*> => SyntaxNode::new_token(IntegerTypeKind::U128.into(), name, ys),
    <name:I8> <ys:Nonsemantic*> => SyntaxNode::new_token(IntegerTypeKind::I8.into(), name, ys),
    <name:I16> <ys:Nonsemantic*> => SyntaxNode::new_token(IntegerTypeKind::I16.into(), name, ys),
    <name:I32> <ys:Nonsemantic*> => SyntaxNode::new_token(IntegerTypeKind::I32.into(), name, ys),
    <name:I64> <ys:Nonsemantic*> => SyntaxNode::new_token(IntegerTypeKind::I64.into(), name, ys),
    <name:I128> <ys:Nonsemantic*> => SyntaxNode::new_token(IntegerTypeKind::I128.into(), name, ys),
}

// Produce an Identifier token whose validity has been checked.
CheckedIdentifier: LalrToken<'a> = {
    <Identifier> => {
        check_identifier(&<>, handler);
        <>
    }
}

// We sometimes want to re-lex identifiers as paths.
#[inline]
Path: LalrToken<'a> = {
    <RealPath>,

    <mut i:Identifier> => {
        i.token = Token::IdVariants(IdVariants::Path);
        i
    },
}

Type2: SyntaxNode<'a> = {
    NamedPrimitiveType,

    <name:WithTrivia<Locator>> => {
        SyntaxNode::new(TypeKind::Composite, [name])
    },

    <name:WithTrivia<Path>> <c:(ConstArgumentList)?> => {
        SyntaxNode::new(TypeKind::Composite, iter::once(name).chain(c))
    },

    <l:WithTrivia<LeftSquare>> <t:Type> <s:WithTrivia<Semicolon>> <i:Expr> <r:WithTrivia<RightSquare>> => {
        SyntaxNode::new(TypeKind::Array, [l, t, s, i, r])
    },

    <WithTrivia<Future>> => {
        SyntaxNode::new(TypeKind::Future, [<>])
    },

    <fut:WithTrivia<Future>> <l:WithTrivia<Lt>> <f:WithTrivia<Fn>> <lparen:WithTrivia<LeftParen>>
    <ts:CommaMaybe<Type>> <rparen:WithTrivia<RightParen>> <r:WithTrivia<Gt>> => {
        SyntaxNode::new(TypeKind::Future, [fut, l, f, lparen].into_iter().chain(ts).chain([rparen, r]))
    },
}

Type: SyntaxNode<'a> = {
    Type2,

    <l:WithTrivia<LeftParen>> <items:CommaTwo<Type>> <r:WithTrivia<RightParen>> => {
        SyntaxNode::new(TypeKind::Tuple, iter::once(l).chain(items).chain([r]))
    },

    // Tuple type with one element - special case for error reporting.
    <l:WithTrivia<LeftParen>> <e:Type> <c:WithTrivia<Comma>?> <r:WithTrivia<RightParen>> => {
        let node = SyntaxNode::new(TypeKind::Tuple, [l, e].into_iter().chain(c).chain([r]));
        handler.emit_err(ParserError::tuple_must_have_at_least_two_elements("type", node.span));
        node
    },

    <l:WithTrivia<LeftParen>> <r:WithTrivia<RightParen>> => {
        SyntaxNode::new(TypeKind::Unit, [l, r])
    },
}

CommaList<T>: Vec<SyntaxNode<'a>> = {
    <items: (<T> <WithTrivia<Comma>>)+> <item:T> => {
        let mut result_items = Vec::with_capacity(2 * items.len() + 1);
        result_items.extend(items.into_iter().flat_map(|(t, c)| [t, c]).chain([item]));
        result_items
    }
}

CommaExpressions: Vec<SyntaxNode<'a>> = CommaList<Expr>;

// Sequence of zero or more comma-delimited items, optionally
// with trailing comma.
#[inline]
CommaMaybe<T>: Vec<SyntaxNode<'a>> = {
    <items: (<T> <WithTrivia<Comma>>)*> <item:(<T>)?> => {
        let mut result_items = Vec::with_capacity(2 * items.len() + 1);
        result_items.extend(items.into_iter().flat_map(|(t, c)| [t, c]).chain(item));
        result_items
    }
}

// Comma delimited list of at least two items, with optional trailing comma.
#[inline]
CommaOne<T>: Vec<SyntaxNode<'a>> = {
    <item0:T> <items:(<WithTrivia<Comma>> <T>)*> <c1:(WithTrivia<Comma>)?> => {
        iter::once(item0).chain(items.into_iter().flat_map(|(x, y)| [x, y])).chain(c1).collect()
    },
}

// Comma delimited list of at least two items, with optional trailing comma.
#[inline]
CommaTwo<T>: Vec<SyntaxNode<'a>> = {
    <item0:T> <c0:WithTrivia<Comma>> <item1:T> <items:(<WithTrivia<Comma>> <T>)*> <c1:(WithTrivia<Comma>)?> => {
        [item0, c0, item1].into_iter().chain(items.into_iter().flat_map(|(x, y)| [x, y])).chain(c1).collect()
    },
}

CommaInitializersMaybe = CommaMaybe<StructMemberInitializer>;

FunctionIdentifier: SyntaxNode<'a> = {
    WithTrivia<Path>,
    WithTrivia<Locator>,
}

WithTrivia<T>: SyntaxNode<'a> = {
    <t:T> <xs:Nonsemantic*> => SyntaxNode::new_token(SyntaxKind::Token, t, xs),
}

NoTrivia<T>: SyntaxNode<'a> = {
    <t:T> => SyntaxNode::new_token(SyntaxKind::Token, t, Vec::new()),
}

StructMemberInitializer: SyntaxNode<'a> = {
    <name:WithTrivia<Identifier>> <c:WithTrivia<Colon>> <e:Expr> => {
        SyntaxNode::new(SyntaxKind::StructMemberInitializer, [name, c, e])
    },

    <name:WithTrivia<Identifier>> => {
        SyntaxNode::new(SyntaxKind::StructMemberInitializer, [name])
    },
}

ExprStruct: SyntaxNode<'a> = {
    // Struct initializer.
    <name:FunctionIdentifier> <c:(ConstArgumentList)?> <l:WithTrivia<LeftCurly>> <inits:CommaInitializersMaybe> <r:WithTrivia<RightCurly>> => {
        // For now the initializer name can't be external.
        if name.text.contains(".aleo") {
            handler.emit_err(ParserError::cannot_define_external_record(name.span));
        }
        SyntaxNode::new(ExpressionKind::Struct, iter::once(name).chain(c).chain([l]).chain(inits).chain([r]))
    },
}

ExprNever: SyntaxNode<'a> = {
    <Never> => panic!("The Never token is never produced."),
}

// Expressions.
//
// Unfortunately we can't just make one big Expr nonterminal. The problem is that there are some
// places where an expression can't contain a struct init due to parsing ambiguities.
// Namely this is the case in condition of `if` statements and the loop bounds of a `for` loop.
//
// Thus we need to handle operator precedence and associativity manually, threading through macros
// two nonterminals - `ExprStruct` which is a struct initializer, and `ExprNever` which is never produced.
//
// It's possible there is a shorter way to implement this than writing a separate nonterminal for each
// precedence level, but this seems a straightforward way for now.
Expr0: SyntaxNode<'a> = {
    // Literal.
    <s:StaticString> <xs:Nonsemantic*> => SyntaxNode::new_token(LiteralKind::String.into(), s, xs),
    <lit:True> <xs:Nonsemantic*> => SyntaxNode::new_token(LiteralKind::Boolean.into(), lit, xs),
    <lit:False> <xs:Nonsemantic*> => SyntaxNode::new_token(LiteralKind::Boolean.into(), lit, xs),
    <lit:AddressLiteral> <xs:Nonsemantic*> => SyntaxNode::new_token(LiteralKind::Address.into(), lit, xs),
    <lit:ProgramId> <xs:Nonsemantic*> => SyntaxNode::new_token(LiteralKind::Address.into(), lit, xs),
    <i:Integer> <s:Field> <xs:Nonsemantic*> => {
        if i.text.starts_with("0x") || i.text.starts_with("0o") || i.text.starts_with("0b") {
            handler.emit_err(ParserError::hexbin_literal_nonintegers(i.span));
        }
        SyntaxNode::suffixed_literal(i, s, xs)
    },
    <i:Integer> <s:Group> <xs:Nonsemantic*> => {
        if i.text.starts_with("0x") || i.text.starts_with("0o") || i.text.starts_with("0b") {
            handler.emit_err(ParserError::hexbin_literal_nonintegers(i.span));
        }
        SyntaxNode::suffixed_literal(i, s, xs)
    },
    <i:Integer> <s:Scalar> <xs:Nonsemantic*> => {
        if i.text.starts_with("0x") || i.text.starts_with("0o") || i.text.starts_with("0b") {
            handler.emit_err(ParserError::hexbin_literal_nonintegers(i.span));
        }
        SyntaxNode::suffixed_literal(i, s, xs)
    },
    <i: Integer> <s: I8> <xs:Nonsemantic*> => SyntaxNode::suffixed_literal(i, s, xs),
    <i: Integer> <s: I16> <xs:Nonsemantic*> => SyntaxNode::suffixed_literal(i, s, xs),
    <i: Integer> <s: I32> <xs:Nonsemantic*> => SyntaxNode::suffixed_literal(i, s, xs),
    <i: Integer> <s: I64> <xs:Nonsemantic*> => SyntaxNode::suffixed_literal(i, s, xs),
    <i: Integer> <s: I128> <xs:Nonsemantic*> => SyntaxNode::suffixed_literal(i, s, xs),
    <i: Integer> <s: U8> <xs:Nonsemantic*> => SyntaxNode::suffixed_literal(i, s, xs),
    <i: Integer> <s: U16> <xs:Nonsemantic*> => SyntaxNode::suffixed_literal(i, s, xs),
    <i: Integer> <s: U32> <xs:Nonsemantic*> => SyntaxNode::suffixed_literal(i, s, xs),
    <i: Integer> <s: U64> <xs:Nonsemantic*> => SyntaxNode::suffixed_literal(i, s, xs),
    <i: Integer> <s: U128> <xs:Nonsemantic*> => SyntaxNode::suffixed_literal(i, s, xs),
    <i: Integer> <xs:Nonsemantic*> => SyntaxNode::new_token(LiteralKind::Unsuffixed.into(), i, xs),

    // Variable or Associated Constant.
    <WithTrivia<Path>> => {
        if matches!(
            crate::two_path_components(<>.text),
            Some(("group", "GEN")),
        ) {
            // It's an associated constant.
            SyntaxNode::new(ExpressionKind::AssociatedConstant, [<>])
        } else {
            // It's a variable.
            SyntaxNode::new(ExpressionKind::Path, [<>])
        }
    },

    // Locator.
    <WithTrivia<Locator>> => SyntaxNode::new(ExpressionKind::Locator, [<>]),

    // Parenthesized expression.
    <l:WithTrivia<LeftParen>> <e:Expr> <r:WithTrivia<RightParen>> => {
        SyntaxNode::new(ExpressionKind::Parenthesized, [l, e, r])
    },

    // Function call or associated function call.
    <name:FunctionIdentifier> <c:(ConstArgumentList)?> <l:WithTrivia<LeftParen>> <exprs:CommaMaybe<Expr>> <r:WithTrivia<RightParen>> => {
        let kind = if c.is_none() && matches!(
            crate::two_path_components(name.text),
            Some(
                (
                    "BHP256" | "BHP512" |"BHP768" | "BHP1024" | "ChaCha" | "Keccak256" | "Keccak384" | "Keccak512" |
                    "Pedersen64" | "Pedersen128" | "Poseidon2" | "Poseidon4" | "Poseidon8" | "SHA3_256" | "SHA3_384" |
                    "SHA3_512" | "Mapping" | "Program" | "signature" | "Future" | "CheatCode" | "group",
                    _
                )
            )
        ) {
            ExpressionKind::AssociatedFunctionCall
        } else {
            ExpressionKind::Call
        };

        SyntaxNode::new(kind, iter::once(name).chain(c).chain([l]).chain(exprs).chain([r]))
    },

    // Tuple expression.
    <l:WithTrivia<LeftParen>> <exprs:CommaTwo<Expr>> <r:WithTrivia<RightParen>> => {
        SyntaxNode::new(ExpressionKind::Tuple, iter::once(l).chain(exprs).chain([r]))
    },

    // Tuple expression with one element - special case for error reporting.
    <l:WithTrivia<LeftParen>> <e:Expr> <c:WithTrivia<Comma>> <r:WithTrivia<RightParen>> => {
        let node = SyntaxNode::new(ExpressionKind::Tuple, [l, e, c, r]);
        handler.emit_err(ParserError::tuple_must_have_at_least_two_elements("expression", node.span));
        node
    },

    // Tuple expression with zero elements - special case for error reporting.
    <l:WithTrivia<LeftParen>> <c:WithTrivia<Comma>?> <r:WithTrivia<RightParen>> => {
        let node = SyntaxNode::new(ExpressionKind::Tuple, iter::once(l).chain(c).chain([r]));
        handler.emit_err(ParserError::tuple_must_have_at_least_two_elements("expression", node.span));
        node
    },

    // Array expression.
    <l:WithTrivia<LeftSquare>> <exprs:CommaOne<Expr>> <r:WithTrivia<RightSquare>> => {
        SyntaxNode::new(ExpressionKind::Array, iter::once(l).chain(exprs).chain([r]))
    },

    // Empty array expression - special cased to give a clear error message.
    <l:WithTrivia<LeftSquare>> <c:(WithTrivia<Comma>)?> <r:WithTrivia<RightSquare>> => {
        let node = SyntaxNode::new(ExpressionKind::Array, iter::once(l).chain(c).chain([r]));
        handler.emit_err(ParserError::array_must_have_at_least_one_element("expression", node.span));
        node
    },

    // Repeat expression.
    <l:WithTrivia<LeftSquare>> <expr:Expr> <s:WithTrivia<Semicolon>> <c:Expr> <r:WithTrivia<RightSquare>> => {
        SyntaxNode::new(ExpressionKind::Repeat, [l, expr, s, c, r])
    },

    // Special access.
    <x:WithTrivia<Block>> <d:WithTrivia<Dot>> <y:WithTrivia<Identifier>> => {
        SyntaxNode::new(ExpressionKind::SpecialAccess, [x, d, y])
    },
    <x:WithTrivia<SelfLower>> <d:WithTrivia<Dot>> <y:WithTrivia<Identifier>> => {
        SyntaxNode::new(ExpressionKind::SpecialAccess, [x, d, y])
    },
    // `address` is otherwise a keyword, so special case it.
    <x:WithTrivia<SelfLower>> <d:WithTrivia<Dot>> <y:WithTrivia<Address>> => {
        SyntaxNode::new(ExpressionKind::SpecialAccess, [x, d, y])
    },
    <x:WithTrivia<Network>> <d:WithTrivia<Dot>> <y:WithTrivia<Identifier>> => {
        SyntaxNode::new(ExpressionKind::SpecialAccess, [x, d, y])
    },

    // async block.
    <a:WithTrivia<Async>> <b:BlockStatement> => {
        SyntaxNode::new(ExpressionKind::Async, [a, b])
    }
}

Expr1<S>: SyntaxNode<'a> = {
    S,

    Expr0,

    // Tuple access.
    <x:Expr1<S>> <d:WithTrivia<Dot>> <i:WithTrivia<Integer>> => {
        SyntaxNode::new(ExpressionKind::TupleAccess, [x, d, i])
    },
    // Array access.
    <x:Expr1<S>> <l:WithTrivia<LeftSquare>> <index:Expr> <r:WithTrivia<RightSquare>> => {
        SyntaxNode::new(ExpressionKind::ArrayAccess, [x, l, index, r])
    },
    // Member access.
    <x:Expr1<S>> <d:WithTrivia<Dot>> <i:WithTrivia<Identifier>> => {
        SyntaxNode::new(ExpressionKind::MemberAccess, [x, d, i])
    },
    // Method call.
    <x:Expr1<S>> <d:WithTrivia<Dot>> <name:WithTrivia<Identifier>> <l:WithTrivia<LeftParen>> <exprs:CommaMaybe<Expr>> <r:WithTrivia<RightParen>> => {
        SyntaxNode::new(ExpressionKind::MethodCall, [x, d, name, l].into_iter().chain(exprs).chain([r]))
    },
}

Op2: SyntaxNode<'a> = {
    WithTrivia<Not>,
    WithTrivia<Sub>,
}

Expr2<S>: SyntaxNode<'a> = {
    Expr1<S>,

    // Unary operations.
    <op:Op2> <x:Expr2<S>> => SyntaxNode::new(ExpressionKind::Unary, [op, x]),
}

Expr3<S>: SyntaxNode<'a> = {
    Expr2<S>,

    <l:Expr3<S>> <a:WithTrivia<As>> <t:NamedPrimitiveType> => {
        SyntaxNode::new(ExpressionKind::Cast, [l, a, t])
    },
}

Expr4<S>: SyntaxNode<'a> = {
    Expr3<S>,

    // Right associative - recurse on the right.
    <l:Expr3<S>> <op:WithTrivia<Pow>> <r:Expr4<S>> => SyntaxNode::binary_expression(l, op, r),
}

LeftAssociativeBinary<Parent, Op>: SyntaxNode<'a> = {
    Parent,

    // Left associative.
    <l:Parent> <rest:(<Op> <Parent>)+> => {
        rest.into_iter().fold(l, |acc, (op, e)| {
            SyntaxNode::new(ExpressionKind::Binary, [acc, op, e])
        })
    }
}

Op5: SyntaxNode<'a> = {
    WithTrivia<Mul>,
    WithTrivia<Div>,
    WithTrivia<Rem>,
}

Expr5<S>: SyntaxNode<'a> = LeftAssociativeBinary<Expr4<S>, Op5>;

Op6: SyntaxNode<'a> = {
    WithTrivia<Add>,
    WithTrivia<Sub>,
}

Expr6<S>: SyntaxNode<'a> = LeftAssociativeBinary<Expr5<S>, Op6>;

Op7: SyntaxNode<'a> = {
    WithTrivia<Shl>,
    WithTrivia<Shr>,
}

Expr7<S>: SyntaxNode<'a> = LeftAssociativeBinary<Expr6<S>, Op7>;

Expr8<S>: SyntaxNode<'a> = LeftAssociativeBinary<Expr7<S>, WithTrivia<BitAnd>>;

Expr9<S>: SyntaxNode<'a> = LeftAssociativeBinary<Expr8<S>, WithTrivia<BitXor>>;

Expr10<S>: SyntaxNode<'a> = LeftAssociativeBinary<Expr9<S>, WithTrivia<BitOr>>;

Op11: SyntaxNode<'a> = {
    WithTrivia<Lt>,
    WithTrivia<Gt>,
    WithTrivia<LtEq>,
    WithTrivia<GtEq>,
}

Expr11<S>: SyntaxNode<'a> = {
    Expr10<S>,

    // Not associative - we could potentially make a special case to give a clearer
    // error message if a user tries something like `a < b < c`.
    <l:Expr10<S>> <op:Op11> <r:Expr10<S>> => {
        SyntaxNode::new(ExpressionKind::Binary, [l, op, r])
    }
}

Op12: SyntaxNode<'a> = {
    WithTrivia<Eq>,
    WithTrivia<NotEq>,
}

Expr12<S>: SyntaxNode<'a> = {
    Expr11<S>,

    // Not associative - we could potentially make a special case to give a clearer
    // error message if a user tries something like `a == b == c`.
    <l:Expr11<S>> <op:Op12> <r:Expr11<S>> => {
        SyntaxNode::new(ExpressionKind::Binary, [l, op, r])
    }
}

Expr13<S>: SyntaxNode<'a> = LeftAssociativeBinary<Expr12<S>, WithTrivia<And>>;

Expr14<S>: SyntaxNode<'a> = LeftAssociativeBinary<Expr13<S>, WithTrivia<Or>>;

Expr15<S>: SyntaxNode<'a> = {
    Expr14<S>,

    // Ternary conditional.
    // <cond:Expr13<S>> <q:WithTrivia<Question>> <a:Expr> <c:WithTrivia<Colon>> <b:Expr13<S>> => {
    //     SyntaxNode::new(ExpressionKind::Ternary, [cond, q, a, c, b])
    // },
    <cond:Expr14<S>> <q:WithTrivia<Question>> <a:Expr15<S>> <c:WithTrivia<Colon>> <b:Expr15<S>> => {
        SyntaxNode::new(ExpressionKind::Ternary, [cond, q, a, c, b])
    },
}


// An expression, including struct inits.
pub Expr: SyntaxNode<'a> = Expr15<ExprStruct>;

// An expression, exluding struct inits in key places.
ExprNoS: SyntaxNode<'a> = Expr15<ExprNever>;

ConstParameter: SyntaxNode<'a> = {
    <v:WithTrivia<Identifier>> <c:WithTrivia<Colon>> <t:Type> => {
        SyntaxNode::new(SyntaxKind::ConstParameter, [v, c, t])
    },
}

ConstParameterList: SyntaxNode<'a> = {
    <c:NoTrivia<DoubleColon>> <l:WithTrivia<LeftSquare>> <ps:CommaMaybe<ConstParameter>> <r:WithTrivia<RightSquare>> => {
        SyntaxNode::new(SyntaxKind::ConstParameterList, [c, l].into_iter().chain(ps).chain([r]))
    },
}

ConstArgumentList: SyntaxNode<'a> = {
    <c:NoTrivia<DoubleColon>> <l:WithTrivia<LeftSquare>> <ps:CommaMaybe<Expr>> <r:WithTrivia<RightSquare>> => {
        SyntaxNode::new(SyntaxKind::ConstArgumentList, [c, l].into_iter().chain(ps).chain([r]))
    },
}

BlockStatement: SyntaxNode<'a> = {
    <l:WithTrivia<LeftCurly>> <stmts:Statement*> <r:WithTrivia<RightCurly>> => {
        SyntaxNode::new(StatementKind::Block, iter::once(l).chain(stmts).chain([r]))
    },
}

ConditionalStatement: SyntaxNode<'a> = {
    <i:WithTrivia<If>> <c:ExprNoS> <b:BlockStatement> => {
        SyntaxNode::new(StatementKind::Conditional, [i, c, b])
    },

    <i:WithTrivia<If>> <c:ExprNoS> <b:BlockStatement> <e:WithTrivia<Else>> <b2:BlockStatement> => {
        SyntaxNode::new(StatementKind::Conditional, [i, c, b, e, b2])
    },

    <i:WithTrivia<If>> <c:ExprNoS> <b:BlockStatement> <e:WithTrivia<Else>> <c2:ConditionalStatement> => {
        SyntaxNode::new(StatementKind::Conditional, [i, c, b, e, c2])
    },
}

AssignmentOperator: LalrToken<'a> = {
    Assign,
    AddAssign,
    SubAssign,
    MulAssign,
    DivAssign,
    RemAssign,
    PowAssign,
    ShlAssign,
    ShrAssign,
    BitAndAssign,
    BitOrAssign,
    BitXorAssign,
    AndAssign,
    OrAssign,
}

pub Statement: SyntaxNode<'a> = {
    // Expression statement.
    <e:Expr> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(StatementKind::Expression, [e, s])
    },

    // Return.
    <r:WithTrivia<Return>> <e:Expr> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(StatementKind::Return, [r, e, s])
    },

    <r: WithTrivia<Return>> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(StatementKind::Return, [r, s])
    },

    // Single place definition, typed.
    <l:WithTrivia<Let>> <i:WithTrivia<CheckedIdentifier>> <c:WithTrivia<Colon>> <t:Type> <a:WithTrivia<Assign>> <e:Expr> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(StatementKind::Definition, [l, i, c, t, a, e, s])
    },

    // Single place definition, no type.
    <l:WithTrivia<Let>> <i:WithTrivia<CheckedIdentifier>> <a:WithTrivia<Assign>> <e:Expr> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(StatementKind::Definition, [l, i, a, e, s])
    },

    // Multiple place definition, typed.
    <l:WithTrivia<Let>> <lp:WithTrivia<LeftParen>> <is:CommaList<WithTrivia<CheckedIdentifier>>> <rp:WithTrivia<RightParen>>
    <c:WithTrivia<Colon>> <t:Type> <a:WithTrivia<Assign>> <e:Expr> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(
            StatementKind::Definition,
            [l, lp].into_iter().chain(is).chain([rp, c, t, a, e, s]),
        )
    },

    // Multiple place definition, no type.
    <l:WithTrivia<Let>> <lp:WithTrivia<LeftParen>> <is:CommaList<WithTrivia<CheckedIdentifier>>> <rp:WithTrivia<RightParen>>
    <a:WithTrivia<Assign>> <e:Expr> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(
            StatementKind::Definition,
            [l, lp].into_iter().chain(is).chain([rp, a, e, s]),
        )
    },

    // Constant.
    <l:WithTrivia<Const>> <i:WithTrivia<CheckedIdentifier>> <c:WithTrivia<Colon>> <t:Type> <a:WithTrivia<Assign>> <e:Expr> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(StatementKind::Const, [l, i, c, t, a, e, s])
    },

    BlockStatement,

    ConditionalStatement,

    // Assignment.
    <lhs:Expr> <a:WithTrivia<AssignmentOperator>> <rhs:Expr> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(StatementKind::Assign, [lhs, a, rhs, s])
    },

    // Loop - no type.
    <f:WithTrivia<For>> <i:WithTrivia<CheckedIdentifier>> <n:WithTrivia<In>> <low:ExprNoS> <d:WithTrivia<DotDot>> <hi:ExprNoS> <b:BlockStatement> => {
        SyntaxNode::new(StatementKind::Iteration, [f, i, n, low, d, hi, b])
    },

    // Loop - type.
    <f:WithTrivia<For>> <i:WithTrivia<CheckedIdentifier>> <c:WithTrivia<Colon>> <t:Type> <n:WithTrivia<In>> <low:ExprNoS> <d:WithTrivia<DotDot>> <hi:ExprNoS> <b:BlockStatement> => {
        SyntaxNode::new(StatementKind::Iteration, [f, i, c, t, n, low, d, hi, b])
    },

    // Assert.
    <a:WithTrivia<Assert>> <l:WithTrivia<LeftParen>> <e:Expr> <r:WithTrivia<RightParen>> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(StatementKind::Assert, [a, l, e, r, s])
    },

    // AssertEq.
    <a:WithTrivia<AssertEq>> <l:WithTrivia<LeftParen>> <e0:Expr> <c:WithTrivia<Comma>> <e1:Expr> <r:WithTrivia<RightParen>> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(StatementKind::AssertEq, [a, l, e0, c, e1, r, s])
    },

    // AssertNeq.
    <a:WithTrivia<AssertNeq>> <l:WithTrivia<LeftParen>> <e0:Expr> <c:WithTrivia<Comma>> <e1:Expr> <r:WithTrivia<RightParen>> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(StatementKind::AssertNeq, [a, l, e0, c, e1, r, s])
    },
}

PrivacyKeyword: LalrToken<'a> = {
    Constant,
    Private,
    Public,
}

Parameter: SyntaxNode<'a> = {
    <p:WithTrivia<PrivacyKeyword>?> <v:WithTrivia<CheckedIdentifier>> <c:WithTrivia<Colon>> <t:Type> => {
        SyntaxNode::new(SyntaxKind::Parameter, p.into_iter().chain([v, c, t]))
    },
}

ParameterList: SyntaxNode<'a> = {
    <l:WithTrivia<LeftParen>> <x:CommaMaybe<Parameter>> <r:WithTrivia<RightParen>> => {
        SyntaxNode::new(SyntaxKind::ParameterList, iter::once(l).chain(x).chain([r]))
    },
}

FunctionKind: LalrToken<'a> = {
    Function,
    Inline,
    Script,
    Transition,
}

FunctionOutput: SyntaxNode<'a> = {
    <p:WithTrivia<PrivacyKeyword>?> <t:Type> => {
        SyntaxNode::new(SyntaxKind::FunctionOutput, p.into_iter().chain([t]))
    },
}

FunctionOutputs: SyntaxNode<'a> = {
    <p:WithTrivia<PrivacyKeyword>?> <t:Type2> => {
        SyntaxNode::new(SyntaxKind::FunctionOutput, p.into_iter().chain([t]))
    },

    <l:WithTrivia<LeftParen>> <o:CommaMaybe<FunctionOutput>> <r:WithTrivia<RightParen>> => {
        SyntaxNode::new(SyntaxKind::FunctionOutputs, iter::once(l).chain(o).chain([r]))
    },
}

AnnotationKey: LalrToken<'a> = {
    Identifier,
    Mapping,
    Address,
}

AnnotationName: LalrToken<'a> = {
    Identifier,
    // The old parser allows the keyword `program` as an annotation name.
    Program,
}

AnnotationMember: SyntaxNode<'a> = {
    <key:WithTrivia<AnnotationKey>> <a:WithTrivia<Assign>> <value:WithTrivia<StaticString>> => {
        SyntaxNode::new(SyntaxKind::AnnotationMember, [key, a, value])
    },
}

AnnotationList: SyntaxNode<'a> = {
    <l:WithTrivia<LeftParen>> <c:CommaMaybe<AnnotationMember>> <r:WithTrivia<RightParen>> => {
        SyntaxNode::new(SyntaxKind::AnnotationList, iter::once(l).chain(c).chain([r]))
    }
}

Annotation: SyntaxNode<'a> = {
    <at:NoTrivia<At>> <n:WithTrivia<AnnotationName>> <list:(AnnotationList)?> => {
        SyntaxNode::new(SyntaxKind::Annotation, [at, n].into_iter().chain(list))
    }
}

// Items.

FunctionDeclarationMacro<FunctionKindKind>: SyntaxNode<'a> = {
     // With a return type.
    <anns:(Annotation)*> <a:WithTrivia<Async>?> <k:WithTrivia<FunctionKindKind>> <name:WithTrivia<CheckedIdentifier>> <c:(<ConstParameterList>)?> <p:ParameterList> <arrow:WithTrivia<Arrow>> <t:FunctionOutputs> <b:BlockStatement> => {
        SyntaxNode::new(SyntaxKind::Function, anns.into_iter().chain(a).chain([k, name]).chain(c).chain([p, arrow, t, b]))
    },

    // No return type.
    <anns:(Annotation)*> <a:WithTrivia<Async>?> <k:WithTrivia<FunctionKindKind>> <name:WithTrivia<CheckedIdentifier>> <c:(<ConstParameterList>)?> <p:ParameterList> <b:BlockStatement> => {
        SyntaxNode::new(SyntaxKind::Function, anns.into_iter().chain(a).chain([k, name]).chain(c).chain([p, b]))
    },
}

InlineDeclaration: SyntaxNode<'a> = FunctionDeclarationMacro<Inline>;

FunctionDeclaration: SyntaxNode<'a> = FunctionDeclarationMacro<FunctionKind>;

ConstructorDeclaration: SyntaxNode<'a> = {
    <anns:(Annotation)*> <a:WithTrivia<Async>> <c:WithTrivia<Constructor>> <l:WithTrivia<LeftParen>> <r:WithTrivia<RightParen>> <b:BlockStatement> => {
        SyntaxNode::new(SyntaxKind::Constructor, anns.into_iter().chain([a, c, l, r, b]))
    },
}

StructComponentKeyword: LalrToken<'a> = {
    <Constant> => <>,
    <Private> => <>,
    <Public> => <>,
}

StructMemberDeclaration: SyntaxNode<'a> = {
    <k:WithTrivia<StructComponentKeyword>?> <i:WithTrivia<CheckedIdentifier>> <c:WithTrivia<Colon>> <t:Type> => {
        SyntaxNode::new(SyntaxKind::StructMemberDeclaration, k.into_iter().chain([i, c, t]))
    },
}

StructMemberDeclarationList: SyntaxNode<'a> = {
    <l:WithTrivia<LeftCurly>> <v:CommaMaybe<StructMemberDeclaration>> <r:WithTrivia<RightCurly>> => {
        SyntaxNode::new(SyntaxKind::StructMemberDeclarationList, iter::once(l).chain(v).chain([r]))
    },
}

StructDeclaration: SyntaxNode<'a> = {
    <s:WithTrivia<Struct>> <i:WithTrivia<CheckedIdentifier>> <c:ConstParameterList?> <m:StructMemberDeclarationList> => {
        SyntaxNode::new(SyntaxKind::StructDeclaration, [s, i].into_iter().chain(c).chain([m]))
    },
}

RecordDeclaration: SyntaxNode<'a> = {
    // We allow a const parameter list so we can later give an error.
    <r:WithTrivia<Record>> <i:WithTrivia<CheckedIdentifier>> <c:ConstParameterList?> <m:StructMemberDeclarationList> => {
        SyntaxNode::new(SyntaxKind::StructDeclaration, [r, i].into_iter().chain(c).chain([m]))
    },
}

GlobalConst: SyntaxNode<'a> = {
    <l:WithTrivia<Const>> <i:WithTrivia<CheckedIdentifier>> <c:WithTrivia<Colon>> <t:Type> <a:WithTrivia<Assign>> <e:Expr> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(SyntaxKind::GlobalConst, [l, i, c, t, a, e, s])
    },
}

MappingDeclaration: SyntaxNode<'a> = {
    <m:WithTrivia<Mapping>> <i:WithTrivia<CheckedIdentifier>> <c:WithTrivia<Colon>> <k:Type> <a:WithTrivia<BigArrow>> <v:Type> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(SyntaxKind::Mapping, [m, i, c, k, a, v, s])
    }
}

Item: SyntaxNode<'a> = {
    ConstructorDeclaration,
    FunctionDeclaration,
    GlobalConst,
    MappingDeclaration,
    RecordDeclaration,
    StructDeclaration,
}

ProgramDeclaration: SyntaxNode<'a> = {
    <p:WithTrivia<Program>> <pid:WithTrivia<ProgramId>> <l:WithTrivia<LeftCurly>> <is:Item*> <r:WithTrivia<RightCurly>> => {
        SyntaxNode::new(SyntaxKind::ProgramDeclaration, [p, pid, l].into_iter().chain(is).chain([r]))
    },

    // For error reporting purposes we catch attempts to declare programs with networks other than `.aleo`.
    <p:WithTrivia<Program>> <name:NoTrivia<Identifier>> <d:NoTrivia<Dot>> <net:WithTrivia<Identifier>> <l:WithTrivia<LeftCurly>> <is:Item*> <r:WithTrivia<RightCurly>> => {
        handler.emit_err(ParserError::invalid_network(net.span));
        SyntaxNode::new(SyntaxKind::ProgramDeclaration, [p, name, d, net, l].into_iter().chain(is).chain([r]))
    },
}

ImportDeclaration: SyntaxNode<'a> = {
    <i:WithTrivia<Import>> <pid:WithTrivia<ProgramId>> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(SyntaxKind::Import, [i, pid, s])
    },
}

pub MainContents: SyntaxNode<'a> = {
    <ns:Nonsemantic*> <is:ImportDeclaration*> <p:ProgramDeclaration> => {
        SyntaxNode::new(SyntaxKind::MainContents, ns.into_iter().chain(is).chain([p]))
    },
}

ModuleItem: SyntaxNode<'a> = {
    InlineDeclaration,
    GlobalConst,
    StructDeclaration,
}

pub ModuleContents: SyntaxNode<'a> = {
    <ns:Nonsemantic*> <is:ModuleItem*> => {
        SyntaxNode::new(SyntaxKind::ModuleContents, ns.into_iter().chain(is))
    },
}

extern {
    type Location = usize;
    type Error = &'static str;

    enum LalrToken<'a> {
        Whitespace => LalrToken { token: Token::Whitespace, .. },
        Linebreak => LalrToken { token: Token::Linebreak, .. },

        CommentLine => LalrToken { token: Token::CommentLine, .. },
        CommentBlock => LalrToken { token: Token::CommentBlock, .. },

        Identifier => LalrToken { token: Token::IdVariants(IdVariants::Identifier), .. },
        ProgramId => LalrToken { token: Token::IdVariants(IdVariants::ProgramId), .. },
        Locator => LalrToken { token: Token::IdVariants(IdVariants::Locator), .. },
        RealPath => LalrToken { token: Token::IdVariants(IdVariants::Path), .. },

        AddressLiteral => LalrToken { token: Token::AddressLiteral, .. },

        Integer => LalrToken { token: Token::Integer, .. },
        StaticString => LalrToken { token: Token::StaticString, .. },

        // Symbols
        Assign => LalrToken { token: Token::Assign, .. },
        Not => LalrToken { token: Token::Not, .. },
        And => LalrToken { token: Token::And, .. },
        Or => LalrToken { token: Token::Or, .. },
        AndAssign => LalrToken { token: Token::AndAssign, .. },
        OrAssign => LalrToken { token: Token::OrAssign, .. },
        BitAnd => LalrToken { token: Token::BitAnd, .. },
        BitAndAssign => LalrToken { token: Token::BitAndAssign, .. },
        BitOr => LalrToken { token: Token::BitOr, .. },
        BitOrAssign => LalrToken { token: Token::BitOrAssign, .. },
        BitXor => LalrToken { token: Token::BitXor, .. },
        BitXorAssign => LalrToken { token: Token::BitXorAssign, .. },
        Eq => LalrToken { token: Token::Eq, .. },
        NotEq => LalrToken { token: Token::NotEq, .. },
        Lt => LalrToken { token: Token::Lt, .. },
        LtEq => LalrToken { token: Token::LtEq, .. },
        Gt => LalrToken { token: Token::Gt, .. },
        GtEq => LalrToken { token: Token::GtEq, .. },
        Add => LalrToken { token: Token::Add, .. },
        AddAssign => LalrToken { token: Token::AddAssign, .. },
        Sub => LalrToken { token: Token::Sub, .. },
        SubAssign => LalrToken { token: Token::SubAssign, .. },
        Mul => LalrToken { token: Token::Mul, .. },
        MulAssign => LalrToken { token: Token::MulAssign, .. },
        Div => LalrToken { token: Token::Div, .. },
        DivAssign => LalrToken { token: Token::DivAssign, .. },
        Pow => LalrToken { token: Token::Pow, .. },
        PowAssign => LalrToken { token: Token::PowAssign, .. },
        Rem => LalrToken { token: Token::Rem, .. },
        RemAssign => LalrToken { token: Token::RemAssign, .. },
        Shl => LalrToken { token: Token::Shl, .. },
        ShlAssign => LalrToken { token: Token::ShlAssign, .. },
        Shr => LalrToken { token: Token::Shr, .. },
        ShrAssign => LalrToken { token: Token::ShrAssign, .. },
        LeftParen => LalrToken { token: Token::LeftParen, .. },
        RightParen => LalrToken { token: Token::RightParen, .. },
        LeftSquare => LalrToken { token: Token::LeftSquare, .. },
        RightSquare => LalrToken { token: Token::RightSquare, .. },
        LeftCurly => LalrToken { token: Token::LeftCurly, .. },
        RightCurly => LalrToken { token: Token::RightCurly, .. },
        Comma => LalrToken { token: Token::Comma, .. },
        Dot => LalrToken { token: Token::Dot, .. },
        DotDot => LalrToken { token: Token::DotDot, .. },
        Semicolon => LalrToken { token: Token::Semicolon, .. },
        Colon => LalrToken { token: Token::Colon, .. },
        DoubleColon => LalrToken{ token: Token::DoubleColon, .. },
        Question => LalrToken{ token: Token::Question, .. },
        Arrow => LalrToken{ token: Token::Arrow, .. },
        BigArrow => LalrToken{ token: Token::BigArrow, .. },
        At => LalrToken{ token: Token::At, .. },
        // Underscore => tokens::Token::Underscore,

        // Keywords
        True => LalrToken { token: Token::True, .. },
        False => LalrToken { token: Token::False, .. },
        Address => LalrToken { token: Token::Address, .. },
        Bool => LalrToken { token: Token::Bool, .. },
        Field => LalrToken { token: Token::Field, .. },
        Group => LalrToken { token: Token::Group, .. },
        Record => LalrToken { token: Token::Record, .. },
        Scalar => LalrToken { token: Token::Scalar, .. },
        Signature => LalrToken { token: Token::Signature, .. },
        Struct => LalrToken { token: Token::Struct, .. },
        String => LalrToken { token: Token::String, .. },

        I8 => LalrToken { token: Token::I8, .. },
        I16 => LalrToken { token: Token::I16, .. },
        I32 => LalrToken { token: Token::I32, .. },
        I64 => LalrToken { token: Token::I64, .. },
        I128 => LalrToken { token: Token::I128, .. },
        U8 => LalrToken { token: Token::U8, .. },
        U16 => LalrToken { token: Token::U16, .. },
        U32 => LalrToken { token: Token::U32, .. },
        U64 => LalrToken { token: Token::U64, .. },
        U128 => LalrToken { token: Token::U128, .. },

        Aleo => LalrToken { token: Token::Aleo, .. },
        As => LalrToken { token: Token::As, .. },
        Assert => LalrToken { token: Token::Assert, .. },
        AssertEq => LalrToken { token: Token::AssertEq, .. },
        AssertNeq => LalrToken { token: Token::AssertNeq, .. },
        Async => LalrToken { token: Token::Async, .. },
        Block => LalrToken { token: Token::Block, .. },
        Const => LalrToken { token: Token::Const, .. },
        Constant => LalrToken { token: Token::Constant, .. },
        Constructor => LalrToken { token: Token::Constructor, .. },
        Else => LalrToken { token: Token::Else, .. },
        Fn => LalrToken { token: Token::Fn, .. },
        For => LalrToken { token: Token::For, .. },
        Function => LalrToken { token: Token::Function, .. },
        Future => LalrToken { token: Token::Future, .. },
        If => LalrToken { token: Token::If, .. },
        Import => LalrToken { token: Token::Import, .. },
        In => LalrToken { token: Token::In, .. },
        Inline => LalrToken { token: Token::Inline, .. },
        Let => LalrToken { token: Token::Let, .. },
        Mapping => LalrToken { token: Token::Mapping, .. },
        Network => LalrToken { token: Token::Network, .. },
        Private => LalrToken { token: Token::Private, .. },
        Program => LalrToken { token: Token::Program, .. },
        Public => LalrToken { token: Token::Public, .. },
        Return => LalrToken { token: Token::Return, .. },
        Script => LalrToken { token: Token::Script, .. },
        SelfLower => LalrToken { token: Token::SelfLower, .. },
        Transition => LalrToken { token: Token::Transition, .. },

        Never => LalrToken { token: Token::Never, .. },
    }
}
