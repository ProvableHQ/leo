
grammar<'a>;

use std::iter;

use lalrpop_util::ParseError;

use crate::tokens::{IdVariants, LalrToken, Token};
use crate::{ExpressionKind, IntegerLiteralKind, IntegerTypeKind, LiteralKind, StatementKind, SyntaxKind, SyntaxNode, TypeKind};

pub Nonsemantic: SyntaxNode<'a> = {
    Whitespace => SyntaxNode::new_token(SyntaxKind::Whitespace, <>, vec![]),
    Linebreak => SyntaxNode::new_token(SyntaxKind::Linebreak, <>, vec![]),
    CommentLine => SyntaxNode::new_token(SyntaxKind::CommentLine, <>, vec![]),
    CommentBlock => SyntaxNode::new_token(SyntaxKind::CommentBlock, <>, vec![]),
}

pub NamedPrimitiveType: SyntaxNode<'a> = {
    <name:Bool> <ys:Nonsemantic*> => SyntaxNode::new_token(TypeKind::Boolean.into(), name, ys),
    <name:Address> <ys:Nonsemantic*> => SyntaxNode::new_token(TypeKind::Address.into(), name, ys),
    <name:Signature> <ys:Nonsemantic*> => SyntaxNode::new_token(TypeKind::Signature.into(), name, ys),
    <name:Field> <ys:Nonsemantic*> => SyntaxNode::new_token(TypeKind::Field.into(), name, ys),
    <name:Group> <ys:Nonsemantic*> => SyntaxNode::new_token(TypeKind::Group.into(), name, ys),
    <name:Scalar> <ys:Nonsemantic*> => SyntaxNode::new_token(TypeKind::Scalar.into(), name, ys),
    <name:U8> <ys:Nonsemantic*> => SyntaxNode::new_token(IntegerTypeKind::U8.into(), name, ys),
    <name:U16> <ys:Nonsemantic*> => SyntaxNode::new_token(IntegerTypeKind::U16.into(), name, ys),
    <name:U32> <ys:Nonsemantic*> => SyntaxNode::new_token(IntegerTypeKind::U32.into(), name, ys),
    <name:U64> <ys:Nonsemantic*> => SyntaxNode::new_token(IntegerTypeKind::U64.into(), name, ys),
    <name:U128> <ys:Nonsemantic*> => SyntaxNode::new_token(IntegerTypeKind::U128.into(), name, ys),
    <name:I8> <ys:Nonsemantic*> => SyntaxNode::new_token(IntegerTypeKind::I8.into(), name, ys),
    <name:I16> <ys:Nonsemantic*> => SyntaxNode::new_token(IntegerTypeKind::I16.into(), name, ys),
    <name:I32> <ys:Nonsemantic*> => SyntaxNode::new_token(IntegerTypeKind::I32.into(), name, ys),
    <name:I64> <ys:Nonsemantic*> => SyntaxNode::new_token(IntegerTypeKind::I64.into(), name, ys),
    <name:I128> <ys:Nonsemantic*> => SyntaxNode::new_token(IntegerTypeKind::I128.into(), name, ys),
}

// We sometimes want to re-lex identifiers as paths.
#[inline]
Path: LalrToken<'a> = {
    <RealPath>,

    <mut i:Identifier> => {
        i.token = Token::IdVariants(IdVariants::Path);
        i
    },
}

Type: SyntaxNode<'a> = {
    NamedPrimitiveType,

    <name:WithTrivia<Path>> <c:(ConstArgumentList)?> => {
        SyntaxNode::new(TypeKind::Composite, iter::once(name).chain(c))
    },

    <l:WithTrivia<LeftSquare>> <t:Type> <s:WithTrivia<Semicolon>> <i:Expr> <r:WithTrivia<RightSquare>> => {
        SyntaxNode::new(TypeKind::Array, [l, t, s, i, r])
    },
}

TypeIncludingTuple: SyntaxNode<'a> = {
    Type,

    <l:WithTrivia<LeftParen>> <items:CommaMaybe<Type>> <r:WithTrivia<RightParen>> => {
        SyntaxNode::new(TypeKind::Tuple, iter::once(l).chain(items).chain([r]))
    },
}

CommaList<T>: Vec<SyntaxNode<'a>> = {
    <items: (<T> <WithTrivia<Comma>>)+> <item:T> => {
        let mut result_items = Vec::with_capacity(2 * items.len() + 1);
        result_items.extend(items.into_iter().flat_map(|(t, c)| [t, c]).chain([item]));
        result_items
    }
}

CommaExpressions: Vec<SyntaxNode<'a>> = CommaList<Expr>;

// Sequence of zero or more comma-delimited items, optionally
// with trailing comma.
CommaMaybe<T>: Vec<SyntaxNode<'a>> = {
    <items: (<T> <WithTrivia<Comma>>)*> <item:(<T>)?> => {
        let mut result_items = Vec::with_capacity(2 * items.len() + 1);
        result_items.extend(items.into_iter().flat_map(|(t, c)| [t, c]).chain(item));
        result_items
    }
}

pub CommaExpressionsMaybe = CommaMaybe<Expr>;

pub CommaInitializersMaybe = CommaMaybe<StructMemberInitializer>;

pub FunctionIdentifier: SyntaxNode<'a> = {
    WithTrivia<Path>,
    WithTrivia<Locator>,
}

// This needs to be inline to avoid shift-reduce conflicts.
#[inline]
WithTrivia<T>: SyntaxNode<'a> = {
    <t:T> <xs:Nonsemantic*> => SyntaxNode::new_token(SyntaxKind::Token, t, xs),
}

NoTrivia<T>: SyntaxNode<'a> = {
    <t:T> => SyntaxNode::new_token(SyntaxKind::Token, t, Vec::new()),
}

pub StructMemberInitializer: SyntaxNode<'a> = {
    <name:WithTrivia<Identifier>> <c:WithTrivia<Colon>> <e:Expr> => {
        SyntaxNode::new(SyntaxKind::StructMemberInitializer, [name, c, e])
    },

    <name:WithTrivia<Identifier>> => {
        SyntaxNode::new(SyntaxKind::StructMemberInitializer, [name])
    },
}

ExprPrimary: SyntaxNode<'a> = {
    #[precedence(level="0")]
    // Literal.
    <lit:True> <xs:Nonsemantic*> => SyntaxNode::new_token(LiteralKind::Boolean.into(), lit, xs),
    <lit:False> <xs:Nonsemantic*> => SyntaxNode::new_token(LiteralKind::Boolean.into(), lit, xs),
    <lit:AddressLiteral> <xs:Nonsemantic*> => SyntaxNode::new_token(LiteralKind::Address.into(), lit, xs),
    <i: Integer> <s: Field> <xs:Nonsemantic*> => SyntaxNode::suffixed_literal2(i, s, xs),
    <i: Integer> <s: Group> <xs:Nonsemantic*> => SyntaxNode::suffixed_literal2(i, s, xs),
    <i: Integer> <s: Scalar> <xs:Nonsemantic*> => SyntaxNode::suffixed_literal2(i, s, xs),
    <i: Integer> <s: I8> <xs:Nonsemantic*> => SyntaxNode::suffixed_literal2(i, s, xs),
    <i: Integer> <s: I16> <xs:Nonsemantic*> => SyntaxNode::suffixed_literal2(i, s, xs),
    <i: Integer> <s: I32> <xs:Nonsemantic*> => SyntaxNode::suffixed_literal2(i, s, xs),
    <i: Integer> <s: I64> <xs:Nonsemantic*> => SyntaxNode::suffixed_literal2(i, s, xs),
    <i: Integer> <s: I128> <xs:Nonsemantic*> => SyntaxNode::suffixed_literal2(i, s, xs),
    <i: Integer> <s: U8> <xs:Nonsemantic*> => SyntaxNode::suffixed_literal2(i, s, xs),
    <i: Integer> <s: U16> <xs:Nonsemantic*> => SyntaxNode::suffixed_literal2(i, s, xs),
    <i: Integer> <s: U32> <xs:Nonsemantic*> => SyntaxNode::suffixed_literal2(i, s, xs),
    <i: Integer> <s: U64> <xs:Nonsemantic*> => SyntaxNode::suffixed_literal2(i, s, xs),
    <i: Integer> <s: U128> <xs:Nonsemantic*> => SyntaxNode::suffixed_literal2(i, s, xs),
    <i: Integer> <xs:Nonsemantic*> => SyntaxNode::new_token(LiteralKind::Unsuffixed.into(), i, xs),

    // Variable or Associated Constant.
    <WithTrivia<Path>> => {
        if matches!(
            crate::two_path_components(<>.text),
            Some(("group", "GEN")),
        ) {
            // It's an associated constant.
            SyntaxNode::new(ExpressionKind::AssociatedConstant, [<>])
        } else {
            // It's a variable.
            SyntaxNode::new(ExpressionKind::Path, [<>])
        }
    },

    // Locator.
    // <l:Locator> <xs:Nonsemantic*> => SyntaxNode::new_token(ExpressionKind::Locator.into(), l, xs),

    // Parenthesized expression.
    <l:WithTrivia<LeftParen>> <e:Expr> <r:WithTrivia<RightParen>> => {
        SyntaxNode::new(ExpressionKind::Parenthesized, [l, e, r])
    },

    // Function call or associated function call.
    <name:FunctionIdentifier> <c:(ConstArgumentList)?> <l:WithTrivia<LeftParen>> <exprs:CommaExpressionsMaybe> <r:WithTrivia<RightParen>> => {
        let kind = if c.is_none() && matches!(
            crate::two_path_components(name.children[0].text),
            Some(
                (
                    "BHP256" | "BHP512" |"BHP768" | "BHP1024" | "ChaCha" | "Keccak256" | "Keccak384" | "Keccak512" |
                    "Pedersen64" | "Pedersen128" | "Poseidon2" | "Poseidon4" | "Poseidon8" | "SHA3_256" | "SHA3_384" |
                    "SHA3_512" | "Mapping" | "group" | "Program" | "signature" | "Future" | "CheatCode",
                    _
                )
            )
        ) {
            ExpressionKind::AssociatedFunctionCall
        } else {
            ExpressionKind::Call
        };

        SyntaxNode::new(kind, iter::once(name).chain(c).chain([l]).chain(exprs).chain([r]))
    },
    // Tuple expression.
    <l:WithTrivia<LeftParen>> <exprs:CommaExpressions> <r:WithTrivia<RightParen>> => {
        SyntaxNode::new(ExpressionKind::Tuple, iter::once(l).chain(exprs).chain([r]))
    },
    // Array expression.
    <l:WithTrivia<LeftSquare>> <exprs:CommaMaybe<Expr>> <r:WithTrivia<RightSquare>> => {
        SyntaxNode::new(ExpressionKind::Array, iter::once(l).chain(exprs).chain([r]))
    },
    // Repeat expression.
    <l:WithTrivia<LeftSquare>> <expr:Expr> <s:WithTrivia<Semicolon>> <c:Expr> <r:WithTrivia<RightSquare>> => {
        SyntaxNode::new(ExpressionKind::Repeat, [l, expr, s, c, r])
    },
    // Special access.
    <x:WithTrivia<Block>> <d:WithTrivia<Dot>> <y:WithTrivia<Identifier>> => {
        SyntaxNode::new(ExpressionKind::SpecialAccess, [x, d, y])
    },
    <x:WithTrivia<SelfLower>> <d:WithTrivia<Dot>> <y:WithTrivia<Identifier>> => {
        SyntaxNode::new(ExpressionKind::SpecialAccess, [x, d, y])
    },
    <x:WithTrivia<Network>> <d:WithTrivia<Dot>> <y:WithTrivia<Identifier>> => {
        SyntaxNode::new(ExpressionKind::SpecialAccess, [x, d, y])
    },

    #[precedence(level="1")]
    // Tuple access.
    <x:ExprPrimary> <d:WithTrivia<Dot>> <i:WithTrivia<Integer>> => {
        SyntaxNode::new(ExpressionKind::TupleAccess, [x, d, i])
    },
    // Array access.
    <x:ExprPrimary> <l:WithTrivia<LeftSquare>> <index:Expr> <r:WithTrivia<RightSquare>> => {
        SyntaxNode::new(ExpressionKind::ArrayAccess, [x, l, index, r])
    },
    // Member access.
    <x:ExprPrimary> <d:WithTrivia<Dot>> <i:WithTrivia<Identifier>> => {
        SyntaxNode::new(ExpressionKind::MemberAccess, [x, d, i])
    },
    // Method call.
    <x:ExprPrimary> <d:WithTrivia<Dot>> <name:WithTrivia<Identifier>> <l:WithTrivia<LeftParen>> <exprs:CommaExpressionsMaybe> <r:WithTrivia<RightParen>> => {
        SyntaxNode::new(ExpressionKind::MethodCall, [x, d, name, l].into_iter().chain(exprs).chain([r]))
    },

    // Unary operations.
    #[precedence(level="2")]
    <op:Not> <ys:Nonsemantic*> <x:ExprPrimary> => SyntaxNode::unary_expression(op, ys, x),
    <op:Sub> <ys:Nonsemantic*> <x:ExprPrimary> => SyntaxNode::unary_expression(op, ys, x),

    // Cast.
    #[precedence(level="3")]
    <l:ExprPrimary> <a:WithTrivia<As>> <t:NamedPrimitiveType> => {
        SyntaxNode::new(ExpressionKind::Cast, [l, a, t])
    },

    // Binary operations.
    #[precedence(level="4")] #[assoc(side="right")]
    Binary<ExprPrimary, Pow, ExprPrimary>,

    #[precedence(level="5")] #[assoc(side="left")]
    Binary<ExprPrimary, Mul, ExprPrimary>,
    Binary<ExprPrimary, Div, ExprPrimary>,
    Binary<ExprPrimary, Rem, ExprPrimary>,

    #[precedence(level="6")] #[assoc(side="left")]
    Binary<ExprPrimary, Add, ExprPrimary>,
    Binary<ExprPrimary, Sub, ExprPrimary>,

    #[precedence(level="7")] #[assoc(side="left")]
    Binary<ExprPrimary, Shl, ExprPrimary>,
    Binary<ExprPrimary, Shr, ExprPrimary>,
}

pub ExprConditional: SyntaxNode<'a> = {
    ExprPrimary,

    // Ternary conditional.
    <cond:ExprPrimary> <q:WithTrivia<Question>> <a:ExprPrimary> <c:WithTrivia<Colon>> <b:ExprPrimary> => {
        SyntaxNode::new(ExpressionKind::Ternary, [cond, q, a, c, b])
    },
}

pub Expr: SyntaxNode<'a> = {
    ExprConditional,

    // Struct initializer. Not part of ExprConditional or ExprPrimary because it can't appear everywhere they can,
    // such as in a conditional. When LR(1) parsing `if x {` we'd have a shift-reduce conflict: is `x` the conditional of
    // the conditional and `{` begins the branch, or is `x {` the beginning of a struct initializer that will be the condition?
    <name:FunctionIdentifier> <c:(ConstArgumentList)?> <l:WithTrivia<LeftCurly>> <inits:CommaInitializersMaybe> <r:WithTrivia<RightCurly>> => {
        SyntaxNode::new(ExpressionKind::Struct, iter::once(name).chain(c).chain([l]).chain(inits).chain([r]))
    },
}

ConstParameter: SyntaxNode<'a> = {
    <v:WithTrivia<Identifier>> <c:WithTrivia<Colon>> <t:Type> => {
        SyntaxNode::new(SyntaxKind::ConstParameter, [v, c, t])
    },
}

ConstParameterList: SyntaxNode<'a> = {
    <c:NoTrivia<DoubleColon>> <l:WithTrivia<LeftSquare>> <ps:CommaMaybe<ConstParameter>> <r:WithTrivia<RightSquare>> => {
        SyntaxNode::new(SyntaxKind::ConstParameterList, [c, l].into_iter().chain(ps).chain([r]))
    },
}

ConstArgumentList: SyntaxNode<'a> = {
    <c:NoTrivia<DoubleColon>> <l:WithTrivia<LeftSquare>> <ps:CommaMaybe<Expr>> <r:WithTrivia<RightSquare>> => {
        SyntaxNode::new(SyntaxKind::ConstArgumentList, [c, l].into_iter().chain(ps).chain([r]))
    },
}

Binary<L, O, R>: SyntaxNode<'a> = {
    <l:L> <op:WithTrivia<O>> <r:R> => SyntaxNode::binary_expression(l, op, r),
}

pub BlockStatement: SyntaxNode<'a> = {
    <l:WithTrivia<LeftCurly>> <stmts:Statement*> <r:WithTrivia<RightCurly>> => {
        SyntaxNode::new(StatementKind::Block, iter::once(l).chain(stmts).chain([r]))
    },
}

pub ConditionalStatement: SyntaxNode<'a> = {
    <i:WithTrivia<If>> <c:ExprConditional> <b:BlockStatement> => {
        SyntaxNode::new(StatementKind::Conditional, [i, c, b])
    },

    <i:WithTrivia<If>> <c:ExprConditional> <b:BlockStatement> <e:WithTrivia<Else>> <b2:BlockStatement> => {
        SyntaxNode::new(StatementKind::Conditional, [i, c, b, e, b2])
    },

    <i:WithTrivia<If>> <c:ExprConditional> <b:BlockStatement> <e:WithTrivia<Else>> <c2:ConditionalStatement> => {
        SyntaxNode::new(StatementKind::Conditional, [i, c, b, e, c2])
    },
}

AssignmentOperator: LalrToken<'a> = {
    <Assign>,
    <AddAssign>,
    <SubAssign>,
    <MulAssign>,
    <DivAssign>,
    <RemAssign>,
    <PowAssign>,
    <ShlAssign>,
    <ShrAssign>,
    <BitAndAssign>,
    <BitOrAssign>,
    <BitXorAssign>,
    <AndAssign>,
    <OrAssign>,
}

pub Statement: SyntaxNode<'a> = {
    // Expression statement.
    <e:Expr> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(StatementKind::Expression, [e, s])
    },

    // Return.
    <r:WithTrivia<Return>> <e:Expr> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(StatementKind::Return, [r, e, s])
    },

    <r: WithTrivia<Return>> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(StatementKind::Return, [r, s])
    },

    // Single place definition, typed.
    <l:WithTrivia<Let>> <i:WithTrivia<Identifier>> <c:WithTrivia<Colon>> <t:TypeIncludingTuple> <a:WithTrivia<Assign>> <e:Expr> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(StatementKind::Definition, [l, i, c, t, a, e, s])
    },

    // Single place definition, no type.
    <l:WithTrivia<Let>> <i:WithTrivia<Identifier>> <a:WithTrivia<Assign>> <e:Expr> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(StatementKind::Definition, [l, i, e, s])
    },

    // Multiple place definition, typed.
    <l:WithTrivia<Let>> <lp:WithTrivia<LeftParen>> <is:CommaList<WithTrivia<Identifier>>> <rp:WithTrivia<RightParen>>
    <i:WithTrivia<Identifier>> <c:WithTrivia<Colon>> <t:TypeIncludingTuple> <a:WithTrivia<Assign>> <e:Expr> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(
            StatementKind::Definition,
            [l, lp].into_iter().chain(is).chain([rp, i, c, t, a, e, s]),
        )
    },

    // Multiple place definition, no type.
    <l:WithTrivia<Let>> <lp:WithTrivia<LeftParen>> <is:CommaList<WithTrivia<Identifier>>> <rp:WithTrivia<RightParen>>
    <i:WithTrivia<Identifier>> <a:WithTrivia<Assign>> <e:Expr> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(
            StatementKind::Definition,
            [l, lp].into_iter().chain(is).chain([rp, i, a, e, s]),
        )
    },

    // Constant.
    <l:WithTrivia<Const>> <i:WithTrivia<Identifier>> <c:WithTrivia<Colon>> <t:TypeIncludingTuple> <e:Expr> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(StatementKind::Const, [l, i, c, t, e, s])
    },

    BlockStatement,

    ConditionalStatement,

    // Assignment.
    <lhs:Expr> <a:WithTrivia<AssignmentOperator>> <rhs:Expr> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(StatementKind::Assign, [lhs, a, rhs, s])
    },

    // Loop - no type.
    <f:WithTrivia<For>> <i:WithTrivia<Identifier>> <n:WithTrivia<In>> <low:ExprConditional> <d:WithTrivia<DotDot>> <hi:ExprConditional> <b:BlockStatement> => {
        SyntaxNode::new(StatementKind::Iteration, [f, i, n, low, d, hi, b])
    },

    // Loop - type.
    <f:WithTrivia<For>> <i:WithTrivia<Identifier>> <c:WithTrivia<Colon>> <t:Type> <n:WithTrivia<In>> <low:ExprConditional> <d:WithTrivia<DotDot>> <hi:ExprConditional> <b:BlockStatement> => {
        SyntaxNode::new(StatementKind::Iteration, [f, i, c, t, n, low, d, hi, b])
    },

    // Assert.
    <a:WithTrivia<Assert>> <l:WithTrivia<LeftParen>> <e:Expr> <r:WithTrivia<RightParen>> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(StatementKind::Assert, [a, l, e, r, s])
    },

    // AssertEq.
    <a:WithTrivia<AssertEq>> <l:WithTrivia<LeftParen>> <e0:Expr> <c:WithTrivia<Comma>> <e1:Expr> <r:WithTrivia<RightParen>> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(StatementKind::AssertEq, [a, l, e0, c, e1, r, s])
    },

    // AssertNeq.
    <a:WithTrivia<AssertNeq>> <l:WithTrivia<LeftParen>> <e0:Expr> <c:WithTrivia<Comma>> <e1:Expr> <r:WithTrivia<RightParen>> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(StatementKind::AssertNeq, [a, l, e0, c, e1, r, s])
    },
}

PrivacyKeyword: LalrToken<'a> = {
    <Public> => <>,
    <Private> => <>,
}

Parameter: SyntaxNode<'a> = {
    <p:WithTrivia<PrivacyKeyword>?> <v:WithTrivia<Identifier>> <c:WithTrivia<Colon>> <t:Type> => {
        SyntaxNode::new(SyntaxKind::Parameter, p.into_iter().chain([v, c, t]))
    },
}

ParameterList: SyntaxNode<'a> = {
    <l:WithTrivia<LeftParen>> <x:CommaMaybe<Parameter>> <r:WithTrivia<RightParen>> => {
        SyntaxNode::new(SyntaxKind::ParameterList, iter::once(l).chain(x).chain([r]))
    },
}

FunctionKind: LalrToken<'a> = {
    <Function> => <>,
    <Inline> => <>,
    <Script> => <>,
    <Transition> => <>,
}

FunctionOutput: SyntaxNode<'a> = {
    <p:WithTrivia<PrivacyKeyword>?> <t:Type> => {
        SyntaxNode::new(SyntaxKind::FunctionOutput, p.into_iter().chain([t]))
    }
}

FunctionOutputs: SyntaxNode<'a> = {
    FunctionOutput,

    <l:WithTrivia<LeftParen>> <o:CommaMaybe<FunctionOutput>> <r:WithTrivia<RightParen>> => {
        SyntaxNode::new(SyntaxKind::FunctionOutputs, iter::once(l).chain(o).chain([r]))
    },
}

AnnotationKey: LalrToken<'a> = {
    Identifier,
    Mapping,
    Address,
}

AnnotationName: LalrToken<'a> = {
    Identifier,
    // The old parser allows the keyword `program` as an annotation name.
    Program,
}

AnnotationMember: SyntaxNode<'a> = {
    <key:WithTrivia<AnnotationKey>> <a:WithTrivia<Assign>> <value:WithTrivia<StaticString>> => {
        SyntaxNode::new(SyntaxKind::AnnotationMember, [key, a, value])
    },
}

AnnotationList: SyntaxNode<'a> = {
    <l:WithTrivia<LeftParen>> <c:CommaMaybe<AnnotationMember>> <r:WithTrivia<RightParen>> => {
        SyntaxNode::new(SyntaxKind::AnnotationList, iter::once(l).chain(c).chain([r]))
    }
}

Annotation: SyntaxNode<'a> = {
    <at:NoTrivia<At>> <n:WithTrivia<AnnotationName>> <list:(AnnotationList)?> => {
        SyntaxNode::new(SyntaxKind::Annotation, [at, n].into_iter().chain(list))
    }
}

// Items.

FunctionDeclarationMacro<FunctionKindKind>: SyntaxNode<'a> = {
     // With a return type.
    <anns:(Annotation)*> <a:WithTrivia<Async>?> <k:WithTrivia<FunctionKindKind>> <name:WithTrivia<Identifier>> <c:(<ConstParameterList>)?> <p:ParameterList> <arrow:WithTrivia<Arrow>> <t:FunctionOutputs> <b:BlockStatement> => {
        SyntaxNode::new(SyntaxKind::Function, anns.into_iter().chain(a).chain([k, name]).chain(c).chain([p, arrow, t, b]))
    },

    // No return type.
    <anns:(Annotation)*> <a:WithTrivia<Async>?> <k:WithTrivia<FunctionKindKind>> <name:WithTrivia<Identifier>> <c:(<ConstParameterList>)?> <p:ParameterList> <b:BlockStatement> => {
        SyntaxNode::new(SyntaxKind::Function, anns.into_iter().chain(a).chain([k, name]).chain(c).chain([p, b]))
    },   
}

InlineDeclaration: SyntaxNode<'a> = FunctionDeclarationMacro<Inline>;

pub FunctionDeclaration: SyntaxNode<'a> = FunctionDeclarationMacro<FunctionKind>;

pub ConstructorDeclaration: SyntaxNode<'a> = {
    <anns:(Annotation)*> <a:WithTrivia<Async>> <c:WithTrivia<Constructor>> <l:WithTrivia<LeftParen>> <r:WithTrivia<RightParen>> <b:BlockStatement> => {
        SyntaxNode::new(SyntaxKind::Constructor, anns.into_iter().chain([a, c, l, r, b]))
    },
}

StructComponentKeyword: LalrToken<'a> = {
    <Constant> => <>,
    <Private> => <>,
    <Public> => <>,
}

StructMemberDeclaration: SyntaxNode<'a> = {
    <k:WithTrivia<StructComponentKeyword>?> <i:WithTrivia<Identifier>> <c:WithTrivia<Colon>> <t:Type> => {
        SyntaxNode::new(SyntaxKind::StructMemberDeclaration, k.into_iter().chain([i, c, t]))
    },
}

StructMemberDeclarationList: SyntaxNode<'a> = {
    <l:WithTrivia<LeftCurly>> <v:CommaMaybe<StructMemberDeclaration>> <r:WithTrivia<RightCurly>> => {
        SyntaxNode::new(SyntaxKind::StructMemberDeclarationList, iter::once(l).chain(v).chain([r]))
    },
}

pub StructDeclaration: SyntaxNode<'a> = {
    <s:WithTrivia<Struct>> <i:WithTrivia<Identifier>> <c:(<ConstParameterList>)?> <m:StructMemberDeclarationList> => {
        SyntaxNode::new(SyntaxKind::StructDeclaration, [s, i].into_iter().chain(c).chain([m]))
    },
}

pub RecordDeclaration: SyntaxNode<'a> = {
    <r:WithTrivia<Record>> <i:WithTrivia<Identifier>> <m:StructMemberDeclarationList> => {
        SyntaxNode::new(SyntaxKind::StructDeclaration, [r, i, m])
    },
}

pub GlobalConst: SyntaxNode<'a> = {
    <l:WithTrivia<Const>> <i:WithTrivia<Identifier>> <c:WithTrivia<Colon>> <t:Type> <e:Expr> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(SyntaxKind::GlobalConst, [l, i, c, t, e, s])
    },
}

pub MappingDeclaration: SyntaxNode<'a> = {
    <m:WithTrivia<Mapping>> <i:WithTrivia<Identifier>> <c:WithTrivia<Colon>> <k:Type> <a:WithTrivia<BigArrow>> <v:Type> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(SyntaxKind::Mapping, [m, i, c, k, a, v, s])
    }
}

Item: SyntaxNode<'a> = {
    <ConstructorDeclaration> => <>,
    <FunctionDeclaration> => <>,
    <GlobalConst> => <>,
    <MappingDeclaration> => <>,
    <RecordDeclaration> => <>,
    <StructDeclaration> => <>,
}

ProgramDeclaration: SyntaxNode<'a> = {
    <p:WithTrivia<Program>> <pid:WithTrivia<ProgramId>> <l:WithTrivia<LeftCurly>> <is:Item*> <r:WithTrivia<RightCurly>> => {
        SyntaxNode::new(SyntaxKind::ProgramDeclaration, [p, pid, l].into_iter().chain(is).chain([r]))
    },
}

ImportDeclaration: SyntaxNode<'a> = {
    <i:WithTrivia<Import>> <pid:WithTrivia<ProgramId>> <s:WithTrivia<Semicolon>> => {
        SyntaxNode::new(SyntaxKind::Import, [i, pid, s])
    },
}

pub MainContents: SyntaxNode<'a> = {
    <ns:Nonsemantic*> <is:ImportDeclaration*> <p:ProgramDeclaration> => {
        SyntaxNode::new(SyntaxKind::MainContents, ns.into_iter().chain(is).chain([p]))
    },
}

ModuleItem: SyntaxNode<'a> = {
    InlineDeclaration,
    GlobalConst,
    StructDeclaration,
}

pub ModuleContents: SyntaxNode<'a> = {
    <ns:Nonsemantic*> <is:ModuleItem*> => {
        SyntaxNode::new(SyntaxKind::ModuleContents, ns.into_iter().chain(is))
    },
}

extern {
    type Location = usize;
    type Error = &'static str;

    enum LalrToken<'a> {
        Whitespace => LalrToken { token: Token::Whitespace, .. },
        Linebreak => LalrToken { token: Token::Linebreak, .. },

        CommentLine => LalrToken { token: Token::CommentLine, .. },
        CommentBlock => LalrToken { token: Token::CommentBlock, .. },

        Identifier => LalrToken { token: Token::IdVariants(IdVariants::Identifier), .. },
        ProgramId => LalrToken { token: Token::IdVariants(IdVariants::ProgramId), .. },
        Locator => LalrToken { token: Token::IdVariants(IdVariants::Locator), .. },
        RealPath => LalrToken { token: Token::IdVariants(IdVariants::Path), .. },

        AddressLiteral => LalrToken { token: Token::AddressLiteral, .. },

        Integer => LalrToken { token: Token::Integer, .. },
        StaticString => LalrToken { token: Token::StaticString, .. },

        // // Symbols
        Assign => LalrToken { token: Token::Assign, .. },
        Not => LalrToken { token: Token::Not, .. },
        And => LalrToken { token: Token::And, .. },
        Or => LalrToken { token: Token::Or, .. },
        AndAssign => LalrToken { token: Token::AndAssign, .. },
        OrAssign => LalrToken { token: Token::OrAssign, .. },
        BitAnd => LalrToken { token: Token::BitAnd, .. },
        BitAndAssign => LalrToken { token: Token::BitAndAssign, .. },
        BitOr => LalrToken { token: Token::BitOr, .. },
        BitOrAssign => LalrToken { token: Token::BitOrAssign, .. },
        BitXor => LalrToken { token: Token::BitXor, .. },
        BitXorAssign => LalrToken { token: Token::BitXorAssign, .. },
        Eq => LalrToken { token: Token::Eq, .. },
        NotEq => LalrToken { token: Token::NotEq, .. },
        Lt => LalrToken { token: Token::Lt, .. },
        LtEq => LalrToken { token: Token::LtEq, .. },
        Gt => LalrToken { token: Token::Gt, .. },
        GtEq => LalrToken { token: Token::GtEq, .. },
        Add => LalrToken { token: Token::Add, .. },
        AddAssign => LalrToken { token: Token::AddAssign, .. },
        Sub => LalrToken { token: Token::Sub, .. },
        SubAssign => LalrToken { token: Token::SubAssign, .. },
        Mul => LalrToken { token: Token::Mul, .. },
        MulAssign => LalrToken { token: Token::MulAssign, .. },
        Div => LalrToken { token: Token::Div, .. },
        DivAssign => LalrToken { token: Token::DivAssign, .. },
        Pow => LalrToken { token: Token::Pow, .. },
        PowAssign => LalrToken { token: Token::PowAssign, .. },
        Rem => LalrToken { token: Token::Rem, .. },
        RemAssign => LalrToken { token: Token::RemAssign, .. },
        Shl => LalrToken { token: Token::Shl, .. },
        ShlAssign => LalrToken { token: Token::ShlAssign, .. },
        Shr => LalrToken { token: Token::Shr, .. },
        ShrAssign => LalrToken { token: Token::ShrAssign, .. },
        LeftParen => LalrToken { token: Token::LeftParen, .. },
        RightParen => LalrToken { token: Token::RightParen, .. },
        LeftSquare => LalrToken { token: Token::LeftSquare, .. },
        RightSquare => LalrToken { token: Token::RightSquare, .. },
        LeftCurly => LalrToken { token: Token::LeftCurly, .. },
        RightCurly => LalrToken { token: Token::RightCurly, .. },
        Comma => LalrToken { token: Token::Comma, .. },
        Dot => LalrToken { token: Token::Dot, .. },
        DotDot => LalrToken { token: Token::DotDot, .. },
        Semicolon => LalrToken { token: Token::Semicolon, .. },
        Colon => LalrToken { token: Token::Colon, .. },
        DoubleColon => LalrToken{ token: Token::DoubleColon, .. },
        Question => LalrToken{ token: Token::Question, .. },
        Arrow => LalrToken{ token: Token::Arrow, .. },
        BigArrow => LalrToken{ token: Token::BigArrow, .. },
        At => LalrToken{ token: Token::At, .. },
//         // Underscore => tokens::Token::Underscore,
//         // At => tokens::Token::At,
//
        // // Keywords
        True => LalrToken { token: Token::True, .. },
        False => LalrToken { token: Token::False, .. },
        Address => LalrToken { token: Token::Address, .. },
        Bool => LalrToken { token: Token::Bool, .. },
        Field => LalrToken { token: Token::Field, .. },
        Group => LalrToken { token: Token::Group, .. },
        Record => LalrToken { token: Token::Record, .. },
        Scalar => LalrToken { token: Token::Scalar, .. },
        Signature => LalrToken { token: Token::Signature, .. },
        Struct => LalrToken { token: Token::Struct, .. },

        I8 => LalrToken { token: Token::I8, .. },
        I16 => LalrToken { token: Token::I16, .. },
        I32 => LalrToken { token: Token::I32, .. },
        I64 => LalrToken { token: Token::I64, .. },
        I128 => LalrToken { token: Token::I128, .. },
        U8 => LalrToken { token: Token::U8, .. },
        U16 => LalrToken { token: Token::U16, .. },
        U32 => LalrToken { token: Token::U32, .. },
        U64 => LalrToken { token: Token::U64, .. },
        U128 => LalrToken { token: Token::U128, .. },

        Aleo => LalrToken { token: Token::Aleo, .. },
        As => LalrToken { token: Token::As, .. },
        Assert => LalrToken { token: Token::Assert, .. },
        AssertEq => LalrToken { token: Token::AssertEq, .. },
        AssertNeq => LalrToken { token: Token::AssertNeq, .. },
        Async => LalrToken { token: Token::Async, .. },
        Block => LalrToken { token: Token::Block, .. },
        Const => LalrToken { token: Token::Const, .. },
        Constant => LalrToken { token: Token::Constant, .. },
        Constructor => LalrToken { token: Token::Constructor, .. },
        Else => LalrToken { token: Token::Else, .. },
        // Fn => tokens::Token::Fn,
        For => LalrToken { token: Token::For, .. },
        Function => LalrToken { token: Token::Function, .. },
        // Future => tokens::Token::Future,
        If => LalrToken { token: Token::If, .. },
        Import => LalrToken { token: Token::Import, .. },
        In => LalrToken { token: Token::In, .. },
        Inline => LalrToken { token: Token::Inline, .. },
        Let => LalrToken { token: Token::Let, .. },
        Mapping => LalrToken { token: Token::Mapping, .. },
        Network => LalrToken { token: Token::Network, .. },
        Private => LalrToken { token: Token::Private, .. },
        Program => LalrToken { token: Token::Program, .. },
        // ProgramId => LalrToken { token: Token::ProgramId, .. },
        Public => LalrToken { token: Token::Public, .. },
        Return => LalrToken { token: Token::Return, .. },
        Script => LalrToken { token: Token::Script, .. },
        SelfLower => LalrToken { token: Token::SelfLower, .. },
        Transition => LalrToken { token: Token::Transition, .. },
    }
}
