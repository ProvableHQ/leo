<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The abstract syntax tree (ast) for a Leo program."><title>leo_ast - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-84e720fa.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="leo_ast" data-themes="" data-resource-suffix="" data-rustdoc-version="1.89.0 (29483883e 2025-08-04)" data-channel="1.89.0" data-search-js="search-92309212.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-4e99c027.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-fd3af306.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../leo_ast/index.html">leo_ast</a><span class="version">3.2.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>leo_ast</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/leo_ast/lib.rs.html#17-199">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The abstract syntax tree (ast) for a Leo program.</p>
<p>This module contains the <a href="struct.Ast.html" title="struct leo_ast::Ast"><code>Ast</code></a> type, a wrapper around the <a href="struct.Program.html" title="struct leo_ast::Program"><code>Program</code></a> type.
The <a href="struct.Ast.html" title="struct leo_ast::Ast"><code>Ast</code></a> type is intended to be parsed and modified by different passes
of the Leo compiler. The Leo compiler can generate a set of R1CS constraints from any <a href="struct.Ast.html" title="struct leo_ast::Ast"><code>Ast</code></a>.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">Â§</a></h2><dl class="item-table reexports"><dt><code>pub use self::<a class="mod" href="common/index.html" title="mod leo_ast::common">common</a>::*;</code></dt><dt><code>pub use self::<a class="mod" href="constructor/index.html" title="mod leo_ast::constructor">constructor</a>::*;</code></dt><dt><code>pub use common::<a class="mod" href="common/node/index.html" title="mod leo_ast::common::node">node</a>::*;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="mod" href="common/index.html" title="mod leo_ast::common">common</a></dt><dt><a class="mod" href="constructor/index.html" title="mod leo_ast::constructor">constructor</a></dt><dt><a class="mod" href="expressions/index.html" title="mod leo_ast::expressions">expressions</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="mod" href="function_stub/index.html" title="mod leo_ast::function_stub">function_<wbr>stub</a></dt><dt><a class="mod" href="functions/index.html" title="mod leo_ast::functions">functions</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="mod" href="indent_display/index.html" title="mod leo_ast::indent_display">indent_<wbr>display</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="mod" href="interpreter_value/index.html" title="mod leo_ast::interpreter_value">interpreter_<wbr>value</a></dt><dt><a class="mod" href="locator/index.html" title="mod leo_ast::locator">locator</a></dt><dt><a class="mod" href="mapping/index.html" title="mod leo_ast::mapping">mapping</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="mod" href="member/index.html" title="mod leo_ast::member">member</a></dt><dt><a class="mod" href="module/index.html" title="mod leo_ast::module">module</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>A Leo module represents a collection of declarations within a single scope,
typically corresponding to a file or logical unit of code. It stores all
relevant definitions associated with a module, including:</dd><dt><a class="mod" href="passes/index.html" title="mod leo_ast::passes">passes</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>This module contains both a Reducer and Visitor design pattern.
These both iterate over the AST.</dd><dt><a class="mod" href="program/index.html" title="mod leo_ast::program">program</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>A Leo program consists of import statements and program scopes.</dd><dt><a class="mod" href="statement/index.html" title="mod leo_ast::statement">statement</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="mod" href="struct/index.html" title="mod leo_ast::struct">struct</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="mod" href="stub/index.html" title="mod leo_ast::stub">stub</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>A stub contains function templates as well as definitions for mappings, structs, records, and constants.</dd><dt><a class="mod" href="types/index.html" title="mod leo_ast::types">types</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="mod" href="value/index.html" title="mod leo_ast::value">value</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt></dl><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.fail2.html" title="macro leo_ast::fail2">fail2</a></dt><dt><a class="macro" href="macro.halt2.html" title="macro leo_ast::halt2">halt2</a></dt><dt><a class="macro" href="macro.halt_no_span2.html" title="macro leo_ast::halt_no_span2">halt_<wbr>no_<wbr>span2</a></dt><dt><a class="macro" href="macro.simple_node_impl.html" title="macro leo_ast::simple_node_impl">simple_<wbr>node_<wbr>impl</a></dt><dt><a class="macro" href="macro.tc_fail2.html" title="macro leo_ast::tc_fail2">tc_<wbr>fail2</a></dt></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Annotation.html" title="struct leo_ast::Annotation">Annotation</a></dt><dd>An annotation, e.g. @program.</dd><dt><a class="struct" href="struct.ArrayAccess.html" title="struct leo_ast::ArrayAccess">Array<wbr>Access</a></dt><dd>An array access expression, e.g., <code>foo[index]</code>.</dd><dt><a class="struct" href="struct.ArrayExpression.html" title="struct leo_ast::ArrayExpression">Array<wbr>Expression</a></dt><dd>An array expression, e.g., <code>[true, false, true, false]</code>.</dd><dt><a class="struct" href="struct.ArrayType.html" title="struct leo_ast::ArrayType">Array<wbr>Type</a></dt><dd>An array type.</dd><dt><a class="struct" href="struct.AssertStatement.html" title="struct leo_ast::AssertStatement">Assert<wbr>Statement</a></dt><dd>An assert statement, <code>assert(&lt;expr&gt;)</code>, <code>assert_eq(&lt;expr&gt;)</code> or <code>assert_neq(&lt;expr&gt;)</code>.</dd><dt><a class="struct" href="struct.AssignStatement.html" title="struct leo_ast::AssignStatement">Assign<wbr>Statement</a></dt><dd>An assignment statement, <code>assignee = value</code>.
Note that there is no operation associated with the assignment.</dd><dt><a class="struct" href="struct.AssociatedConstantExpression.html" title="struct leo_ast::AssociatedConstantExpression">Associated<wbr>Constant<wbr>Expression</a></dt><dd>An access expression to a struct constant., e.g. <code>u8::MAX</code>.</dd><dt><a class="struct" href="struct.AssociatedFunctionExpression.html" title="struct leo_ast::AssociatedFunctionExpression">Associated<wbr>Function<wbr>Expression</a></dt><dd>An access expression to an associated function in a struct, e.g.<code>Pedersen64::hash()</code>.</dd><dt><a class="struct" href="struct.Ast.html" title="struct leo_ast::Ast">Ast</a></dt><dd>The abstract syntax tree (AST) for a Leo program.</dd><dt><a class="struct" href="struct.AsyncExpression.html" title="struct leo_ast::AsyncExpression">Async<wbr>Expression</a></dt><dd>An <code>async</code> block: e.g. <code>async { my_mapping.set(1, 2); }</code>.</dd><dt><a class="struct" href="struct.BinaryExpression.html" title="struct leo_ast::BinaryExpression">Binary<wbr>Expression</a></dt><dd>A binary expression <code>left op right</code> of two operands separated by some operator.
For example, <code>foo + bar</code>.</dd><dt><a class="struct" href="struct.Block.html" title="struct leo_ast::Block">Block</a></dt><dd>A block <code>{ [stmt]* }</code> consisting of a list of statements to execute in order.</dd><dt><a class="struct" href="struct.CallExpression.html" title="struct leo_ast::CallExpression">Call<wbr>Expression</a></dt><dd>A function call expression, e.g.<code>foo(args)</code> or <code>Foo::bar(args)</code>.</dd><dt><a class="struct" href="struct.CastExpression.html" title="struct leo_ast::CastExpression">Cast<wbr>Expression</a></dt><dd>A cast expression, e.g. <code>42u8 as u16</code>.</dd><dt><a class="struct" href="struct.Composite.html" title="struct leo_ast::Composite">Composite</a></dt><dd>A composite type definition, e.g., <code>struct Foo { my_field: Bar }</code> and <code>record Token { owner: address, amount: u64}</code>.
In some languages these are called <code>struct</code>s.</dd><dt><a class="struct" href="struct.CompositeType.html" title="struct leo_ast::CompositeType">Composite<wbr>Type</a></dt><dd>A composite type of a identifier and external program name.</dd><dt><a class="struct" href="struct.ConditionalStatement.html" title="struct leo_ast::ConditionalStatement">Conditional<wbr>Statement</a></dt><dd>An <code>if condition block (else next)?</code> statement.</dd><dt><a class="struct" href="struct.ConstDeclaration.html" title="struct leo_ast::ConstDeclaration">Const<wbr>Declaration</a></dt><dd>A constant declaration statement.</dd><dt><a class="struct" href="struct.DefinitionStatement.html" title="struct leo_ast::DefinitionStatement">Definition<wbr>Statement</a></dt><dd>A <code>let</code> or <code>const</code> declaration statement.</dd><dt><a class="struct" href="struct.ErrExpression.html" title="struct leo_ast::ErrExpression">ErrExpression</a></dt><dd>Represents a syntactically invalid expression.</dd><dt><a class="struct" href="struct.ExpressionStatement.html" title="struct leo_ast::ExpressionStatement">Expression<wbr>Statement</a></dt><dd>An expression statement, <code>foo(a);</code>.</dd><dt><a class="struct" href="struct.Function.html" title="struct leo_ast::Function">Function</a></dt><dd>A function definition.</dd><dt><a class="struct" href="struct.FunctionStub.html" title="struct leo_ast::FunctionStub">Function<wbr>Stub</a></dt><dd>A function stub definition.</dd><dt><a class="struct" href="struct.FutureType.html" title="struct leo_ast::FutureType">Future<wbr>Type</a></dt><dd>A future type consisting of the type of the inputs.</dd><dt><a class="struct" href="struct.Input.html" title="struct leo_ast::Input">Input</a></dt><dd>A function parameter.</dd><dt><a class="struct" href="struct.IterationStatement.html" title="struct leo_ast::IterationStatement">Iteration<wbr>Statement</a></dt><dd>A bounded <code>for</code> loop statement <code>for variable in start .. =? stop block</code>.</dd><dt><a class="struct" href="struct.Literal.html" title="struct leo_ast::Literal">Literal</a></dt><dd>A literal.</dd><dt><a class="struct" href="struct.LocatorExpression.html" title="struct leo_ast::LocatorExpression">Locator<wbr>Expression</a></dt><dd>A locator that references an external resource.</dd><dt><a class="struct" href="struct.Mapping.html" title="struct leo_ast::Mapping">Mapping</a></dt><dd>A mapping declaration, e.g <code>mapping balances: address =&gt; u128</code>.</dd><dt><a class="struct" href="struct.MappingType.html" title="struct leo_ast::MappingType">Mapping<wbr>Type</a></dt><dd>A mapping type of a key and value type.</dd><dt><a class="struct" href="struct.Member.html" title="struct leo_ast::Member">Member</a></dt><dd>A member of a structured data type, e.g <code>foobar: u8</code> or <code>private baz: bool</code> .</dd><dt><a class="struct" href="struct.MemberAccess.html" title="struct leo_ast::MemberAccess">Member<wbr>Access</a></dt><dd>A struct member access expression <code>inner.name</code> to some structure with <em>named members</em>.</dd><dt><a class="struct" href="struct.Module.html" title="struct leo_ast::Module">Module</a></dt><dd>Stores the abstract syntax tree of a Leo module.</dd><dt><a class="struct" href="struct.Output.html" title="struct leo_ast::Output">Output</a></dt><dd>A function output.</dd><dt><a class="struct" href="struct.Program.html" title="struct leo_ast::Program">Program</a></dt><dd>Stores the Leo program abstract syntax tree.</dd><dt><a class="struct" href="struct.ProgramId.html" title="struct leo_ast::ProgramId">Program<wbr>Id</a></dt><dd>An identifier for a program that is eventually deployed to the network.</dd><dt><a class="struct" href="struct.ProgramScope.html" title="struct leo_ast::ProgramScope">Program<wbr>Scope</a></dt><dd>Stores the Leo program scope abstract syntax tree.</dd><dt><a class="struct" href="struct.RepeatExpression.html" title="struct leo_ast::RepeatExpression">Repeat<wbr>Expression</a></dt><dd>An array expression constructed from one repeated element.</dd><dt><a class="struct" href="struct.ReturnStatement.html" title="struct leo_ast::ReturnStatement">Return<wbr>Statement</a></dt><dd>A return statement <code>return expression;</code>.</dd><dt><a class="struct" href="struct.StructExpression.html" title="struct leo_ast::StructExpression">Struct<wbr>Expression</a></dt><dd>A struct initialization expression, e.g., <code>Foo { bar: 42, baz }</code>.</dd><dt><a class="struct" href="struct.StructVariableInitializer.html" title="struct leo_ast::StructVariableInitializer">Struct<wbr>Variable<wbr>Initializer</a></dt><dd>An initializer for a single field / variable of a struct initializer expression.
That is, in <code>Foo { bar: 42, baz }</code>, this is either <code>bar: 42</code>, or <code>baz</code>.</dd><dt><a class="struct" href="struct.Stub.html" title="struct leo_ast::Stub">Stub</a></dt><dd>Stores the Leo stub abstract syntax tree.</dd><dt><a class="struct" href="struct.TernaryExpression.html" title="struct leo_ast::TernaryExpression">Ternary<wbr>Expression</a></dt><dd>A ternary conditional expression, that is, <code>condition ? if_true : if_false</code>.</dd><dt><a class="struct" href="struct.TupleAccess.html" title="struct leo_ast::TupleAccess">Tuple<wbr>Access</a></dt><dd>A tuple access expression, e.g., <code>tuple.index</code>.</dd><dt><a class="struct" href="struct.TupleExpression.html" title="struct leo_ast::TupleExpression">Tuple<wbr>Expression</a></dt><dd>A tuple expression, e.g., <code>(foo, false, 42)</code>.</dd><dt><a class="struct" href="struct.TupleType.html" title="struct leo_ast::TupleType">Tuple<wbr>Type</a></dt><dd>A type list of at least two types.</dd><dt><a class="struct" href="struct.UnaryExpression.html" title="struct leo_ast::UnaryExpression">Unary<wbr>Expression</a></dt><dd>An unary expression applying an operator to an inner expression.</dd><dt><a class="struct" href="struct.UnitExpression.html" title="struct leo_ast::UnitExpression">Unit<wbr>Expression</a></dt><dd>Represents a unit expression.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.AssertVariant.html" title="enum leo_ast::AssertVariant">Assert<wbr>Variant</a></dt><dd>A variant of an assert statement.</dd><dt><a class="enum" href="enum.BinaryOperation.html" title="enum leo_ast::BinaryOperation">Binary<wbr>Operation</a></dt><dd>A binary operator.</dd><dt><a class="enum" href="enum.CoreConstant.html" title="enum leo_ast::CoreConstant">Core<wbr>Constant</a></dt><dd>A core constant that maps directly to an AVM bytecode constant.</dd><dt><a class="enum" href="enum.CoreFunction.html" title="enum leo_ast::CoreFunction">Core<wbr>Function</a></dt><dd>A core instruction that maps directly to an AVM bytecode instruction.</dd><dt><a class="enum" href="enum.DefinitionPlace.html" title="enum leo_ast::DefinitionPlace">Definition<wbr>Place</a></dt><dt><a class="enum" href="enum.Expression.html" title="enum leo_ast::Expression">Expression</a></dt><dd>Expression that evaluates to a value.</dd><dt><a class="enum" href="enum.IntegerType.html" title="enum leo_ast::IntegerType">Integer<wbr>Type</a></dt><dd>Explicit integer type.</dd><dt><a class="enum" href="enum.LiteralVariant.html" title="enum leo_ast::LiteralVariant">Literal<wbr>Variant</a></dt><dt><a class="enum" href="enum.Mode.html" title="enum leo_ast::Mode">Mode</a></dt><dd>The mode associated with a type.</dd><dt><a class="enum" href="enum.Statement.html" title="enum leo_ast::Statement">Statement</a></dt><dd>Program statement that defines some action (or expression) to be carried out.</dd><dt><a class="enum" href="enum.Type.html" title="enum leo_ast::Type">Type</a></dt><dd>Explicit type used for defining a variable or expression type</dd><dt><a class="enum" href="enum.UnaryOperation.html" title="enum leo_ast::UnaryOperation">Unary<wbr>Operation</a></dt><dd>A unary operator for a unary expression.</dd><dt><a class="enum" href="enum.Value.html" title="enum leo_ast::Value">Value</a></dt><dt><a class="enum" href="enum.Variant.html" title="enum leo_ast::Variant">Variant</a></dt><dd>Functions are always one of six variants.
A transition function is permitted the ability to manipulate records.
An asynchronous transition function is a transition function that calls an asynchronous function.
A regular function is not permitted to manipulate records.
An asynchronous function contains on-chain operations.
An inline function is directly copied at the call site.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.AstReconstructor.html" title="trait leo_ast::AstReconstructor">AstReconstructor</a></dt><dd>A Reconstructor trait for types in the AST.</dd><dt><a class="trait" href="trait.AstVisitor.html" title="trait leo_ast::AstVisitor">AstVisitor</a></dt><dd>A Visitor trait for types in the AST.</dd><dt><a class="trait" href="trait.ConstructorConsumer.html" title="trait leo_ast::ConstructorConsumer">Constructor<wbr>Consumer</a></dt><dd>A Consumer trait for constructors in the AST.</dd><dt><a class="trait" href="trait.ExpressionConsumer.html" title="trait leo_ast::ExpressionConsumer">Expression<wbr>Consumer</a></dt><dd>A Consumer trait for expressions in the AST.</dd><dt><a class="trait" href="trait.FromStrRadix.html" title="trait leo_ast::FromStrRadix">From<wbr>StrRadix</a></dt><dd>This trait allows to parse integer literals of any type generically.</dd><dt><a class="trait" href="trait.FunctionConsumer.html" title="trait leo_ast::FunctionConsumer">Function<wbr>Consumer</a></dt><dd>A Consumer trait for functions in the AST.</dd><dt><a class="trait" href="trait.ImportConsumer.html" title="trait leo_ast::ImportConsumer">Import<wbr>Consumer</a></dt><dd>A Consumer trait for imported programs in the AST.</dd><dt><a class="trait" href="trait.MappingConsumer.html" title="trait leo_ast::MappingConsumer">Mapping<wbr>Consumer</a></dt><dd>A Consumer trait for mappings in the AST.</dd><dt><a class="trait" href="trait.ModuleConsumer.html" title="trait leo_ast::ModuleConsumer">Module<wbr>Consumer</a></dt><dd>A Consumer trait for modules in the AST.</dd><dt><a class="trait" href="trait.ProgramConsumer.html" title="trait leo_ast::ProgramConsumer">Program<wbr>Consumer</a></dt><dd>A Consumer trait for the program represented by the AST.</dd><dt><a class="trait" href="trait.ProgramReconstructor.html" title="trait leo_ast::ProgramReconstructor">Program<wbr>Reconstructor</a></dt><dd>A Reconstructor trait for the program represented by the AST.</dd><dt><a class="trait" href="trait.ProgramScopeConsumer.html" title="trait leo_ast::ProgramScopeConsumer">Program<wbr>Scope<wbr>Consumer</a></dt><dd>A Consumer trait for program scopes in the AST.</dd><dt><a class="trait" href="trait.ProgramVisitor.html" title="trait leo_ast::ProgramVisitor">Program<wbr>Visitor</a></dt><dd>A Visitor trait for the program represented by the AST.</dd><dt><a class="trait" href="trait.StatementConsumer.html" title="trait leo_ast::StatementConsumer">Statement<wbr>Consumer</a></dt><dd>A Consumer trait for statements in the AST.</dd><dt><a class="trait" href="trait.StructConsumer.html" title="trait leo_ast::StructConsumer">Struct<wbr>Consumer</a></dt><dd>A Consumer trait for structs in the AST.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.normalize_json_value.html" title="fn leo_ast::normalize_json_value">normalize_<wbr>json_<wbr>value</a></dt><dd>Helper function to normalize AST JSON into a form compatible with tgc.
This function will traverse the original JSON value and produce a new
one under the following rules:</dd><dt><a class="fn" href="fn.remove_key_from_json.html" title="fn leo_ast::remove_key_from_json">remove_<wbr>key_<wbr>from_<wbr>json</a></dt><dd>Helper function to recursively filter keys from AST JSON</dd></dl><script type="text/json" id="notable-traits-data">{"&'static [u8]":"<h3>Notable traits for <code>&amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.89.0/std/primitive.u8.html\">u8</a>]</code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.89.0/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.89.0/std/primitive.u8.html\">u8</a>]</div>"}</script></section></div></main></body></html>