program test.aleo;

closure reverse_bits:
    input r0 as u8;
    gt r0 0u8 into r1;
    shl 0u8 1u8 into r2;
    and r0 1u8 into r3;
    is.eq r3 1u8 into r4;
    xor r2 1u8 into r5;
    ternary r4 r5 r2 into r6;
    shr r0 1u8 into r7;
    ternary r1 r6 0u8 into r8;
    ternary r1 r7 r0 into r9;
    gt r9 0u8 into r10;
    shl r8 1u8 into r11;
    and r9 1u8 into r12;
    is.eq r12 1u8 into r13;
    xor r11 1u8 into r14;
    ternary r13 r14 r11 into r15;
    shr r9 1u8 into r16;
    ternary r10 r15 r8 into r17;
    ternary r10 r16 r9 into r18;
    gt r18 0u8 into r19;
    shl r17 1u8 into r20;
    and r18 1u8 into r21;
    is.eq r21 1u8 into r22;
    xor r20 1u8 into r23;
    ternary r22 r23 r20 into r24;
    shr r18 1u8 into r25;
    ternary r19 r24 r17 into r26;
    ternary r19 r25 r18 into r27;
    gt r27 0u8 into r28;
    shl r26 1u8 into r29;
    and r27 1u8 into r30;
    is.eq r30 1u8 into r31;
    xor r29 1u8 into r32;
    ternary r31 r32 r29 into r33;
    shr r27 1u8 into r34;
    ternary r28 r33 r26 into r35;
    ternary r28 r34 r27 into r36;
    gt r36 0u8 into r37;
    shl r35 1u8 into r38;
    and r36 1u8 into r39;
    is.eq r39 1u8 into r40;
    xor r38 1u8 into r41;
    ternary r40 r41 r38 into r42;
    shr r36 1u8 into r43;
    ternary r37 r42 r35 into r44;
    ternary r37 r43 r36 into r45;
    gt r45 0u8 into r46;
    shl r44 1u8 into r47;
    and r45 1u8 into r48;
    is.eq r48 1u8 into r49;
    xor r47 1u8 into r50;
    ternary r49 r50 r47 into r51;
    shr r45 1u8 into r52;
    ternary r46 r51 r44 into r53;
    ternary r46 r52 r45 into r54;
    gt r54 0u8 into r55;
    shl r53 1u8 into r56;
    and r54 1u8 into r57;
    is.eq r57 1u8 into r58;
    xor r56 1u8 into r59;
    ternary r58 r59 r56 into r60;
    shr r54 1u8 into r61;
    ternary r55 r60 r53 into r62;
    ternary r55 r61 r54 into r63;
    gt r63 0u8 into r64;
    shl r62 1u8 into r65;
    and r63 1u8 into r66;
    is.eq r66 1u8 into r67;
    xor r65 1u8 into r68;
    ternary r67 r68 r65 into r69;
    shr r63 1u8 into r70;
    ternary r64 r69 r62 into r71;
    output r71 as u8;

function fibonacci:
    input r0 as u8.public;
    lte r0 64u8 into r1;
    assert.eq r1 true;
    call reverse_bits r0 into r2;
    gt r0 0u8 into r3;
    mul 1u128 1u128 into r4;
    mul 0u128 0u128 into r5;
    add r4 r5 into r6;
    mul 2u128 1u128 into r7;
    sub r7 0u128 into r8;
    mul 0u128 r8 into r9;
    shl 1u8 0u8 into r10;
    and r2 r10 into r11;
    is.eq r11 0u8 into r12;
    add r9 r6 into r13;
    ternary r12 r9 r6 into r14;
    ternary r12 r6 r13 into r15;
    add 0u8 1u8 into r16;
    shr r0 1u8 into r17;
    ternary r3 r14 0u128 into r18;
    ternary r3 r15 1u128 into r19;
    ternary r3 r16 0u8 into r20;
    ternary r3 r17 r0 into r21;
    gt r21 0u8 into r22;
    mul r19 r19 into r23;
    mul r18 r18 into r24;
    add r23 r24 into r25;
    mul 2u128 r19 into r26;
    sub r26 r18 into r27;
    mul r18 r27 into r28;
    shl 1u8 r20 into r29;
    and r2 r29 into r30;
    is.eq r30 0u8 into r31;
    add r28 r25 into r32;
    ternary r31 r28 r25 into r33;
    ternary r31 r25 r32 into r34;
    add r20 1u8 into r35;
    shr r21 1u8 into r36;
    ternary r22 r33 r18 into r37;
    ternary r22 r34 r19 into r38;
    ternary r22 r35 r20 into r39;
    ternary r22 r36 r21 into r40;
    gt r40 0u8 into r41;
    mul r38 r38 into r42;
    mul r37 r37 into r43;
    add r42 r43 into r44;
    mul 2u128 r38 into r45;
    sub r45 r37 into r46;
    mul r37 r46 into r47;
    shl 1u8 r39 into r48;
    and r2 r48 into r49;
    is.eq r49 0u8 into r50;
    add r47 r44 into r51;
    ternary r50 r47 r44 into r52;
    ternary r50 r44 r51 into r53;
    add r39 1u8 into r54;
    shr r40 1u8 into r55;
    ternary r41 r52 r37 into r56;
    ternary r41 r53 r38 into r57;
    ternary r41 r54 r39 into r58;
    ternary r41 r55 r40 into r59;
    gt r59 0u8 into r60;
    mul r57 r57 into r61;
    mul r56 r56 into r62;
    add r61 r62 into r63;
    mul 2u128 r57 into r64;
    sub r64 r56 into r65;
    mul r56 r65 into r66;
    shl 1u8 r58 into r67;
    and r2 r67 into r68;
    is.eq r68 0u8 into r69;
    add r66 r63 into r70;
    ternary r69 r66 r63 into r71;
    ternary r69 r63 r70 into r72;
    add r58 1u8 into r73;
    shr r59 1u8 into r74;
    ternary r60 r71 r56 into r75;
    ternary r60 r72 r57 into r76;
    ternary r60 r73 r58 into r77;
    ternary r60 r74 r59 into r78;
    gt r78 0u8 into r79;
    mul r76 r76 into r80;
    mul r75 r75 into r81;
    add r80 r81 into r82;
    mul 2u128 r76 into r83;
    sub r83 r75 into r84;
    mul r75 r84 into r85;
    shl 1u8 r77 into r86;
    and r2 r86 into r87;
    is.eq r87 0u8 into r88;
    add r85 r82 into r89;
    ternary r88 r85 r82 into r90;
    ternary r88 r82 r89 into r91;
    add r77 1u8 into r92;
    shr r78 1u8 into r93;
    ternary r79 r90 r75 into r94;
    ternary r79 r91 r76 into r95;
    ternary r79 r92 r77 into r96;
    ternary r79 r93 r78 into r97;
    gt r97 0u8 into r98;
    mul r95 r95 into r99;
    mul r94 r94 into r100;
    add r99 r100 into r101;
    mul 2u128 r95 into r102;
    sub r102 r94 into r103;
    mul r94 r103 into r104;
    shl 1u8 r96 into r105;
    and r2 r105 into r106;
    is.eq r106 0u8 into r107;
    add r104 r101 into r108;
    ternary r107 r104 r101 into r109;
    ternary r107 r101 r108 into r110;
    add r96 1u8 into r111;
    shr r97 1u8 into r112;
    ternary r98 r109 r94 into r113;
    ternary r98 r110 r95 into r114;
    ternary r98 r111 r96 into r115;
    ternary r98 r112 r97 into r116;
    gt r116 0u8 into r117;
    mul r114 r114 into r118;
    mul r113 r113 into r119;
    add r118 r119 into r120;
    mul 2u128 r114 into r121;
    sub r121 r113 into r122;
    mul r113 r122 into r123;
    shl 1u8 r115 into r124;
    and r2 r124 into r125;
    is.eq r125 0u8 into r126;
    add r123 r120 into r127;
    ternary r126 r123 r120 into r128;
    ternary r126 r120 r127 into r129;
    add r115 1u8 into r130;
    shr r116 1u8 into r131;
    ternary r117 r128 r113 into r132;
    ternary r117 r129 r114 into r133;
    ternary r117 r130 r115 into r134;
    ternary r117 r131 r116 into r135;
    gt r135 0u8 into r136;
    mul r133 r133 into r137;
    mul r132 r132 into r138;
    add r137 r138 into r139;
    mul 2u128 r133 into r140;
    sub r140 r132 into r141;
    mul r132 r141 into r142;
    shl 1u8 r134 into r143;
    and r2 r143 into r144;
    is.eq r144 0u8 into r145;
    add r142 r139 into r146;
    ternary r145 r142 r139 into r147;
    add r134 1u8 into r148;
    shr r135 1u8 into r149;
    ternary r136 r147 r132 into r150;
    output r150 as u128.private;
