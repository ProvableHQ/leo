program opt_bug.aleo;

struct S:
    x as u32;

struct Optional__3FgA2LC7NnF:
    is_some as boolean;
    val as S;

struct OS:
    inner as Optional__3FgA2LC7NnF;

struct Optional__EsDmm5O6sv6:
    is_some as boolean;
    val as u32;

struct Optional__AS933TMAJfN:
    is_some as boolean;
    val as [Optional__EsDmm5O6sv6; 2u32];

struct Wrap:
    arr as Optional__AS933TMAJfN;
    val as Optional__EsDmm5O6sv6;

function assign_optional_from_unwrap:
    cast true 5u32 into r0 as Optional__EsDmm5O6sv6;
    assert.eq r0.is_some true;
    cast true r0.val into r1 as Optional__EsDmm5O6sv6;
    assert.eq r0.is_some true;
    add r0.val 7u32 into r2;
    cast true r2 into r3 as Optional__EsDmm5O6sv6;
    ternary r0.is_some r0.val 0u32 into r4;
    cast true r4 into r5 as Optional__EsDmm5O6sv6;
    assert.eq r1.is_some true;
    assert.eq r3.is_some true;
    assert.eq r5.is_some true;
    add r1.val r3.val into r6;
    add r6 r5.val into r7;
    output r7 as u32.private;

function unwrap_inside_expression:
    cast true 9u32 into r0 as Optional__EsDmm5O6sv6;
    assert.eq r0.is_some true;
    mul r0.val 2u32 into r1;
    add r1 3u32 into r2;
    output r2 as u32.private;

function nested_expression_unwraps:
    cast true 4u32 into r0 as Optional__EsDmm5O6sv6;
    cast true 6u32 into r1 as Optional__EsDmm5O6sv6;
    assert.eq r0.is_some true;
    assert.eq r1.is_some true;
    assert.eq r0.is_some true;
    mul r1.val r0.val into r2;
    add r0.val r2 into r3;
    output r3 as u32.private;

function unwrap_in_arrays:
    cast true 1u32 into r0 as Optional__EsDmm5O6sv6;
    cast false 0u32 into r1 as Optional__EsDmm5O6sv6;
    cast true 3u32 into r2 as Optional__EsDmm5O6sv6;
    cast r0 r1 r2 into r3 as [Optional__EsDmm5O6sv6; 3u32];
    assert.eq r3[0u32].is_some true;
    assert.eq r3[2u32].is_some true;
    ternary r3[1u32].is_some r3[1u32].val 10u32 into r4;
    add r3[0u32].val r4 into r5;
    add r5 r3[2u32].val into r6;
    output r6 as u32.private;

function optional_array_handling:
    cast true 7u32 into r0 as Optional__EsDmm5O6sv6;
    cast false 0u32 into r1 as Optional__EsDmm5O6sv6;
    cast r0 r1 into r2 as [Optional__EsDmm5O6sv6; 2u32];
    cast true r2 into r3 as Optional__AS933TMAJfN;
    assert.eq r3.is_some true;
    assert.eq r3.val[0u32].is_some true;
    output r3.val[0u32].val as u32.private;

function optional_struct_field_expr:
    cast 11u32 into r0 as S;
    cast true r0 into r1 as Optional__3FgA2LC7NnF;
    cast r1 into r2 as OS;
    assert.eq r2.inner.is_some true;
    add r2.inner.val.x 5u32 into r3;
    output r3 as u32.private;

function optional_struct_unwrap_assign:
    cast 30u32 into r0 as S;
    cast true r0 into r1 as Optional__3FgA2LC7NnF;
    assert.eq r1.is_some true;
    add r1.val.x 12u32 into r2;
    cast true r2 into r3 as Optional__EsDmm5O6sv6;
    assert.eq r3.is_some true;
    output r3.val as u32.private;

function nested_struct_array_mix:
    cast true 1u32 into r0 as Optional__EsDmm5O6sv6;
    cast false 0u32 into r1 as Optional__EsDmm5O6sv6;
    cast r0 r1 into r2 as [Optional__EsDmm5O6sv6; 2u32];
    cast true r2 into r3 as Optional__AS933TMAJfN;
    cast false 0u32 into r4 as Optional__EsDmm5O6sv6;
    cast r3 r4 into r5 as Wrap;
    assert.eq r5.arr.is_some true;
    ternary r5.arr.val[0u32].is_some r5.arr.val[0u32].val 0u32 into r6;
    ternary r5.arr.val[1u32].is_some r5.arr.val[1u32].val 20u32 into r7;
    add r6 r7 into r8;
    output r8 as u32.private;

function tuple_optional_fields:
    cast true 4u32 into r0 as Optional__EsDmm5O6sv6;
    assert.eq r0.is_some true;
    add r0.val 9u32 into r1;
    output r1 as u32.private;

function optionals_in_function_context:
    cast true 6u32 into r0 as Optional__EsDmm5O6sv6;
    cast false 0u32 into r1 as Optional__EsDmm5O6sv6;
    assert.eq r0.is_some true;
    add r0.val 2u32 into r2;
    ternary r1.is_some r1.val 4u32 into r3;
    mul r2 r3 into r4;
    output r4 as u32.private;

function stress_compound_unwrap:
    cast true 2u32 into r0 as Optional__EsDmm5O6sv6;
    cast true 3u32 into r1 as Optional__EsDmm5O6sv6;
    cast false 0u32 into r2 as Optional__EsDmm5O6sv6;
    assert.eq r0.is_some true;
    assert.eq r1.is_some true;
    assert.eq r0.is_some true;
    assert.eq r1.is_some true;
    assert.eq r0.is_some true;
    assert.eq r1.is_some true;
    add r0.val r1.val into r3;
    mul r0.val r1.val into r4;
    add r3 r4 into r5;
    ternary r2.is_some r2.val 7u32 into r6;
    add r5 r6 into r7;
    add r0.val r1.val into r8;
    add r7 r8 into r9;
    output r9 as u32.private;

function ternary_optional_cases:
    cast true 10u32 into r0 as Optional__EsDmm5O6sv6;
    cast false 0u32 into r1 as Optional__EsDmm5O6sv6;
    assert.eq r0.is_some true;
    assert.eq r0.is_some true;
    add r0.val 5u32 into r2;
    cast true r2 into r3 as Optional__EsDmm5O6sv6;
    cast r3.is_some r3.val into r4 as Optional__EsDmm5O6sv6;
    assert.eq r4.is_some true;
    mul r4.val 2u32 into r5;
    assert.eq r1.is_some true;
    assert.eq r0.is_some true;
    cast false 0u32 into r6 as Optional__EsDmm5O6sv6;
    is.neq r1 r6 into r7;
    add r0.val 1u32 into r8;
    ternary r7 r1.val r8 into r9;
    cast true r9 into r10 as Optional__EsDmm5O6sv6;
    cast r10.is_some r10.val into r11 as Optional__EsDmm5O6sv6;
    assert.eq r4.is_some true;
    assert.eq r11.is_some true;
    add r0.val r4.val into r12;
    add r12 r5 into r13;
    add r13 r9 into r14;
    add r14 r11.val into r15;
    output r15 as u32.private;
