namespace = "Compile"
expectation = "Pass"
outputs = [[{ compile = [
    { initial_ast = "5a07ca97b09d15a8549692408a74444dc346fbd3c8d08b1e3fa4dc60d2a0a05c", unrolled_ast = "5a07ca97b09d15a8549692408a74444dc346fbd3c8d08b1e3fa4dc60d2a0a05c", ssa_ast = "50c140777b792e917824e9021e722774b3e037f2d97c9d0c59a14b2c5088c98b", flattened_ast = "70095a548c925b64465f7782a4f526c852ba3d8fea9460360100f0f812c31745", destructured_ast = "6a018c1d6f75e09550ba4a7ea1a5a013e6310bb627d848cf2f493fd7558d48df", inlined_ast = "23474689d4cfa0c96042c017ebc36ba2422265e38d562d3f108ddff0a937b444", dce_ast = "23474689d4cfa0c96042c017ebc36ba2422265e38d562d3f108ddff0a937b444", bytecode = """
program test.aleo;

mapping foo:
    key as u32.public;
    value as u32.public;

function main_inner:
    input r0 as u32.public;
    input r1 as u32.public;
    async main_inner r0 r1 into r2;
    output r2 as test.aleo/main_inner.future;

finalize main_inner:
    input r0 as u32.public;
    input r1 as u32.public;
    set r1 into foo[r0];

function baz:
    input r0 as u32.private;
    input r1 as u32.private;
    add r0 r1 into r2;
    output r2 as u32.private;
""", errors = "", warnings = "" },
    { initial_ast = "959ef8008a2cb837e0f067c6954356034892bed1a8dcda72224f08e360a1c791", unrolled_ast = "16d8f807e713ffc02c41e1e1c2b8f983877da24be7844f2daed7de7928ecaa70", ssa_ast = "e0ab686b156b3eeeef7dc4ee4771741aec683e0d735f930147e1646fb2bde2ee", flattened_ast = "54f8e60e04ad219b582eecb7cbd924c5f51615a29795871c321856a63da06639", destructured_ast = "02404cf5fc5964e66dc95a32821f14cd7b8269d957c9aa7894a79505d398f04c", inlined_ast = "309192c19217f2c0ae496e8bb920670dc70343c3e33bb9a1170c82261ede409c", dce_ast = "309192c19217f2c0ae496e8bb920670dc70343c3e33bb9a1170c82261ede409c", bytecode = """
import test.aleo;
program basic.aleo;

function main:
    input r0 as u32.public;
    input r1 as u32.private;
    call test.aleo/baz r0 r1 into r2;
    assert.eq r2 1u32;
    call test.aleo/main_inner 0u32 0u32 into r3;
    call test.aleo/baz r0 r1 into r4;
    assert.eq r4 1u32;
    call test.aleo/main_inner 1u32 1u32 into r5;
    call test.aleo/baz r0 r1 into r6;
    assert.eq r6 1u32;
    async main r3 r5 into r7;
    output r7 as basic.aleo/main.future;

finalize main:
    input r0 as test.aleo/main_inner.future;
    input r1 as test.aleo/main_inner.future;
    await r0;
    await r1;
""", errors = "", warnings = "" },
] }]]
