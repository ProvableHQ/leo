namespace = "Compile"
expectation = "Pass"
outputs = [[{ compile = [
    { initial_ast = "5a07ca97b09d15a8549692408a74444dc346fbd3c8d08b1e3fa4dc60d2a0a05c", unrolled_ast = "5a07ca97b09d15a8549692408a74444dc346fbd3c8d08b1e3fa4dc60d2a0a05c", ssa_ast = "50c140777b792e917824e9021e722774b3e037f2d97c9d0c59a14b2c5088c98b", flattened_ast = "765d76ca2e311922ecb69f3b5dfa74dee46ba29a5e4fe8ff44ddfd53c2d4b0c3", destructured_ast = "b2de0cd0b81376e139bc2faa80107c73a34e4ae8cdf2ad56ca90fe45cf6ce1bd", inlined_ast = "71e6e8c9370affd420f0b835400bbf6183b5f57fdccb4f6657d0ebe36f58ba43", dce_ast = "71e6e8c9370affd420f0b835400bbf6183b5f57fdccb4f6657d0ebe36f58ba43", bytecode = """
program test.aleo;

mapping foo:
    key as u32.public;
    value as u32.public;

function main_inner:
    input r0 as u32.public;
    input r1 as u32.public;
    async main_inner r0 r1 into r2;
    output r2 as test.aleo/main_inner.future;

finalize main_inner:
    input r0 as u32.public;
    input r1 as u32.public;
    set r1 into foo[r0];

function baz:
    input r0 as u32.private;
    input r1 as u32.private;
    add r0 r1 into r2;
    output r2 as u32.private;
""", errors = "", warnings = "" },
    { initial_ast = "959ef8008a2cb837e0f067c6954356034892bed1a8dcda72224f08e360a1c791", unrolled_ast = "16d8f807e713ffc02c41e1e1c2b8f983877da24be7844f2daed7de7928ecaa70", ssa_ast = "e0ab686b156b3eeeef7dc4ee4771741aec683e0d735f930147e1646fb2bde2ee", flattened_ast = "60f083afcf97524d01e0606163ac2ba9c11e0768587cd762f15adbbfbd33601b", destructured_ast = "9d6e34a9ec961c53f51788dd921b8577e57a7e6d2c2c029b808b6128d424a1f7", inlined_ast = "af08a5f0cbbc5ed9934612466ab01261876fafba55f8b3778c3a5e7c1195ca2a", dce_ast = "af08a5f0cbbc5ed9934612466ab01261876fafba55f8b3778c3a5e7c1195ca2a", bytecode = """
import test.aleo;
program basic.aleo;

function main:
    input r0 as u32.public;
    input r1 as u32.private;
    call test.aleo/baz r0 r1 into r2;
    assert.eq r2 1u32;
    call test.aleo/main_inner 0u32 0u32 into r3;
    call test.aleo/baz r0 r1 into r4;
    assert.eq r4 1u32;
    call test.aleo/main_inner 1u32 1u32 into r5;
    call test.aleo/baz r0 r1 into r6;
    assert.eq r6 1u32;
    async main r3 r5 into r7;
    output r7 as basic.aleo/main.future;

finalize main:
    input r0 as test.aleo/main_inner.future;
    input r1 as test.aleo/main_inner.future;
    await r0;
    await r1;
""", errors = "", warnings = "" },
] }]]
