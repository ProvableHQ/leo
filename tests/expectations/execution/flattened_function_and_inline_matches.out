program test.aleo;

struct Extra:
    c as u8;

struct Data:
    a as u8;
    b as u8;
    c as Extra;

closure foo:
    input r0 as u8;
    input r1 as u8;
    input r2 as Data;
    cast r0 into r3 as Extra;
    cast r0 r1 r3 into r4 as Data;
    is.eq r0 r1 into r5;
    add r0 r1 into r6;
    sub r0 r1 into r7;
    add r6 r2.a into r8;
    add r7 r2.b into r9;
    ternary r5 r4.c.c r4.c.c into r10;
    cast r10 into r11 as Extra;
    ternary r5 r4.a r4.a into r12;
    ternary r5 r4.b r4.b into r13;
    cast r12 r13 r11 into r14 as Data;
    ternary r5 r0 r8 into r15;
    ternary r5 r1 r9 into r16;
    output r15 as u8;
    output r16 as u8;
    output r14 as Data;

function bar:
    input r0 as boolean.private;
    input r1 as boolean.private;
    input r2 as u8.private;
    input r3 as u8.private;
    cast r2 into r4 as Extra;
    cast r2 r3 r4 into r5 as Data;
    call foo r2 r3 r5 into r6 r7 r8;
    call foo r6 r8.c.c r8 into r9 r10 r11;
    call foo r7 r8.b r8 into r12 r13 r14;
    call foo r8.a r7 r8 into r15 r16 r17;
    ternary r1 r12 r15 into r18;
    ternary r1 r13 r16 into r19;
    ternary r1 r14.c.c r17.c.c into r20;
    cast r20 into r21 as Extra;
    ternary r1 r14.a r17.a into r22;
    ternary r1 r14.b r17.b into r23;
    cast r22 r23 r21 into r24 as Data;
    ternary r0 r9 r18 into r25;
    ternary r0 r10 r19 into r26;
    ternary r0 r11.c.c r24.c.c into r27;
    cast r27 into r28 as Extra;
    ternary r0 r11.a r24.a into r29;
    ternary r0 r11.b r24.b into r30;
    cast r29 r30 r28 into r31 as Data;
    output r25 as u8.private;
    output r26 as u8.private;
    output r31 as Data.private;

closure floo:
    input r0 as u8;
    input r1 as u8;
    input r2 as Data;
    cast r0 into r3 as Extra;
    cast r0 r1 r3 into r4 as Data;
    is.eq r0 r1 into r5;
    add r0 r1 into r6;
    sub r0 r1 into r7;
    add r6 r2.a into r8;
    add r7 r2.b into r9;
    ternary r5 r4.c.c r4.c.c into r10;
    cast r10 into r11 as Extra;
    ternary r5 r4.a r4.a into r12;
    ternary r5 r4.b r4.b into r13;
    cast r12 r13 r11 into r14 as Data;
    ternary r5 r0 r8 into r15;
    ternary r5 r1 r9 into r16;
    output r15 as u8;
    output r16 as u8;
    output r14 as Data;

function blar:
    input r0 as boolean.private;
    input r1 as boolean.private;
    input r2 as u8.private;
    input r3 as u8.private;
    cast r2 into r4 as Extra;
    cast r2 r3 r4 into r5 as Data;
    call floo r2 r3 r5 into r6 r7 r8;
    call floo r6 r8.c.c r8 into r9 r10 r11;
    call floo r7 r8.b r8 into r12 r13 r14;
    call floo r8.a r7 r8 into r15 r16 r17;
    ternary r1 r12 r15 into r18;
    ternary r1 r13 r16 into r19;
    ternary r1 r14.c.c r17.c.c into r20;
    cast r20 into r21 as Extra;
    ternary r1 r14.a r17.a into r22;
    ternary r1 r14.b r17.b into r23;
    cast r22 r23 r21 into r24 as Data;
    ternary r0 r9 r18 into r25;
    ternary r0 r10 r19 into r26;
    ternary r0 r11.c.c r24.c.c into r27;
    cast r27 into r28 as Extra;
    ternary r0 r11.a r24.a into r29;
    ternary r0 r11.b r24.b into r30;
    cast r29 r30 r28 into r31 as Data;
    output r25 as u8.private;
    output r26 as u8.private;
    output r31 as Data.private;

constructor:
    assert.eq edition 0u16;
status: success
output: (4u8, 1u8, {a: 2u8, b: 1u8, c: {
  c: 2u8
}})
status: success
output: (1u8, 1u8, {a: 1u8, b: 1u8, c: {
  c: 1u8
}})
status: success
output: (5u8, 2u8, {a: 2u8, b: 1u8, c: {
  c: 2u8
}})
status: success
output: (2u8, 2u8, {a: 2u8, b: 2u8, c: {
  c: 2u8
}})
status: success
output: (4u8, 1u8, {a: 2u8, b: 1u8, c: {
  c: 2u8
}})
status: success
output: (1u8, 1u8, {a: 1u8, b: 1u8, c: {
  c: 1u8
}})
status: success
output: (5u8, 2u8, {a: 2u8, b: 1u8, c: {
  c: 2u8
}})
status: success
output: (2u8, 2u8, {a: 2u8, b: 2u8, c: {
  c: 2u8
}})
