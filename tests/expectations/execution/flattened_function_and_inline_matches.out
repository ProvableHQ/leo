program test.aleo;

struct Extra:
    c as u8;

struct Data:
    a as u8;
    b as u8;
    c as Extra;

function bar:
    input r0 as boolean.private;
    input r1 as boolean.private;
    input r2 as u8.private;
    input r3 as u8.private;
    cast r2 into r4 as Extra;
    cast r2 r3 r4 into r5 as Data;
    cast r2 into r6 as Extra;
    cast r2 r3 r6 into r7 as Data;
    is.eq r2 r3 into r8;
    add r2 r3 into r9;
    sub r2 r3 into r10;
    add r9 r5.a into r11;
    add r10 r5.b into r12;
    ternary r8 r7.c.c r7.c.c into r13;
    cast r13 into r14 as Extra;
    ternary r8 r7.a r7.a into r15;
    ternary r8 r7.b r7.b into r16;
    cast r15 r16 r14 into r17 as Data;
    ternary r8 r2 r11 into r18;
    ternary r8 r3 r12 into r19;
    cast r18 into r20 as Extra;
    cast r18 r17.c.c r20 into r21 as Data;
    is.eq r18 r17.c.c into r22;
    add r18 r17.c.c into r23;
    sub r18 r17.c.c into r24;
    add r23 r17.a into r25;
    add r24 r17.b into r26;
    ternary r22 r21.c.c r21.c.c into r27;
    cast r27 into r28 as Extra;
    ternary r22 r21.a r21.a into r29;
    ternary r22 r21.b r21.b into r30;
    cast r29 r30 r28 into r31 as Data;
    ternary r22 r18 r25 into r32;
    ternary r22 r17.c.c r26 into r33;
    cast r19 into r34 as Extra;
    cast r19 r17.b r34 into r35 as Data;
    is.eq r19 r17.b into r36;
    add r19 r17.b into r37;
    sub r19 r17.b into r38;
    add r37 r17.a into r39;
    add r38 r17.b into r40;
    ternary r36 r35.c.c r35.c.c into r41;
    cast r41 into r42 as Extra;
    ternary r36 r35.a r35.a into r43;
    ternary r36 r35.b r35.b into r44;
    cast r43 r44 r42 into r45 as Data;
    ternary r36 r19 r39 into r46;
    ternary r36 r17.b r40 into r47;
    cast r17.a into r48 as Extra;
    cast r17.a r19 r48 into r49 as Data;
    is.eq r17.a r19 into r50;
    add r17.a r19 into r51;
    sub r17.a r19 into r52;
    add r51 r17.a into r53;
    add r52 r17.b into r54;
    ternary r50 r49.c.c r49.c.c into r55;
    cast r55 into r56 as Extra;
    ternary r50 r49.a r49.a into r57;
    ternary r50 r49.b r49.b into r58;
    cast r57 r58 r56 into r59 as Data;
    ternary r50 r17.a r53 into r60;
    ternary r50 r19 r54 into r61;
    ternary r1 r46 r60 into r62;
    ternary r1 r47 r61 into r63;
    ternary r1 r45.c.c r59.c.c into r64;
    cast r64 into r65 as Extra;
    ternary r1 r45.a r59.a into r66;
    ternary r1 r45.b r59.b into r67;
    cast r66 r67 r65 into r68 as Data;
    ternary r0 r32 r62 into r69;
    ternary r0 r33 r63 into r70;
    ternary r0 r31.c.c r68.c.c into r71;
    cast r71 into r72 as Extra;
    ternary r0 r31.a r68.a into r73;
    ternary r0 r31.b r68.b into r74;
    cast r73 r74 r72 into r75 as Data;
    output r69 as u8.private;
    output r70 as u8.private;
    output r75 as Data.private;

closure floo:
    input r0 as u8;
    input r1 as u8;
    input r2 as Data;
    cast r0 into r3 as Extra;
    cast r0 r1 r3 into r4 as Data;
    is.eq r0 r1 into r5;
    add r0 r1 into r6;
    sub r0 r1 into r7;
    add r6 r2.a into r8;
    add r7 r2.b into r9;
    ternary r5 r4.c.c r4.c.c into r10;
    cast r10 into r11 as Extra;
    ternary r5 r4.a r4.a into r12;
    ternary r5 r4.b r4.b into r13;
    cast r12 r13 r11 into r14 as Data;
    ternary r5 r0 r8 into r15;
    ternary r5 r1 r9 into r16;
    output r15 as u8;
    output r16 as u8;
    output r14 as Data;

function blar:
    input r0 as boolean.private;
    input r1 as boolean.private;
    input r2 as u8.private;
    input r3 as u8.private;
    cast r2 into r4 as Extra;
    cast r2 r3 r4 into r5 as Data;
    call floo r2 r3 r5 into r6 r7 r8;
    call floo r6 r8.c.c r8 into r9 r10 r11;
    call floo r7 r8.b r8 into r12 r13 r14;
    call floo r8.a r7 r8 into r15 r16 r17;
    ternary r1 r12 r15 into r18;
    ternary r1 r13 r16 into r19;
    ternary r1 r14.c.c r17.c.c into r20;
    cast r20 into r21 as Extra;
    ternary r1 r14.a r17.a into r22;
    ternary r1 r14.b r17.b into r23;
    cast r22 r23 r21 into r24 as Data;
    ternary r0 r9 r18 into r25;
    ternary r0 r10 r19 into r26;
    ternary r0 r11.c.c r24.c.c into r27;
    cast r27 into r28 as Extra;
    ternary r0 r11.a r24.a into r29;
    ternary r0 r11.b r24.b into r30;
    cast r29 r30 r28 into r31 as Data;
    output r25 as u8.private;
    output r26 as u8.private;
    output r31 as Data.private;

constructor:
    assert.eq edition 0u16;
status: success
output: (4u8, 1u8, {a: 2u8, b: 1u8, c: {
  c: 2u8
}})
status: success
output: (1u8, 1u8, {a: 1u8, b: 1u8, c: {
  c: 1u8
}})
status: success
output: (5u8, 2u8, {a: 2u8, b: 1u8, c: {
  c: 2u8
}})
status: success
output: (2u8, 2u8, {a: 2u8, b: 2u8, c: {
  c: 2u8
}})
status: success
output: (4u8, 1u8, {a: 2u8, b: 1u8, c: {
  c: 2u8
}})
status: success
output: (1u8, 1u8, {a: 1u8, b: 1u8, c: {
  c: 1u8
}})
status: success
output: (5u8, 2u8, {a: 2u8, b: 1u8, c: {
  c: 2u8
}})
status: success
output: (2u8, 2u8, {a: 2u8, b: 2u8, c: {
  c: 2u8
}})
