program complex.aleo {
    @noupgrade
    async constructor() {
    }
    struct Point {
        x: field,
        y: field,
    }
    struct Stats {
        values: [u32; 3],
        active: bool,
    }
    mapping point__: bool => complex.aleo/Point;
    mapping points__: bool => [complex.aleo/Point; 2];
    mapping stats__: bool => complex.aleo/Stats;
    mapping arr_u32__: bool => [u32; 3];
    mapping arr_bool__: bool => [bool; 2];
    mapping nested__: bool => [[u8; 2]; 2];
    fn initialize() -> Final<Fn()> {
        return async {
            _mapping_set(complex.aleo/point__, false, complex.aleo/Point { x: 1field, y: 2field });
            _mapping_set(complex.aleo/points__, false, [complex.aleo/Point { x: 10field, y: 20field }, complex.aleo/Point { x: 30field, y: 40field }]);
            _mapping_set(complex.aleo/stats__, false, complex.aleo/Stats { values: [5u32, 10u32, 15u32], active: true });
            _mapping_set(complex.aleo/arr_u32__, false, [7u32, 8u32, 9u32]);
            _mapping_set(complex.aleo/arr_bool__, false, [true, false]);
            _mapping_set(complex.aleo/nested__, false, [[1u8, 2u8], [3u8, 4u8]]);
        };
    }
    fn to_none() -> Final<Fn()> {
        return async {
            _mapping_remove(complex.aleo/point__, false);
            _mapping_remove(complex.aleo/points__, false);
            _mapping_remove(complex.aleo/stats__, false);
            _mapping_remove(complex.aleo/arr_u32__, false);
            _mapping_remove(complex.aleo/arr_bool__, false);
            _mapping_remove(complex.aleo/nested__, false);
        };
    }
    fn check1() -> Final<Fn()> {
        return async {
            let p = _optional_unwrap(_mapping_contains(complex.aleo/point__, false) ? _mapping_get_or_use(complex.aleo/point__, false, complex.aleo/Point { x: 0field, y: 0field }) : none);
            assert(p.x == 1field);
            assert(p.y == 2field);
            let ps = _optional_unwrap(_mapping_contains(complex.aleo/points__, false) ? _mapping_get_or_use(complex.aleo/points__, false, [complex.aleo/Point { x: 0field, y: 0field }; 2]) : none);
            assert(ps[0].x == 10field);
            assert(ps[1].y == 40field);
            let s = _optional_unwrap(_mapping_contains(complex.aleo/stats__, false) ? _mapping_get_or_use(complex.aleo/stats__, false, complex.aleo/Stats { values: [0u32; 3], active: false }) : none);
            assert(s.values[1] == 10u32);
            assert(s.active == true);
            let a = _optional_unwrap(_mapping_contains(complex.aleo/arr_u32__, false) ? _mapping_get_or_use(complex.aleo/arr_u32__, false, [0u32; 3]) : none);
            assert(a[2] == 9u32);
            let b = _optional_unwrap(_mapping_contains(complex.aleo/arr_bool__, false) ? _mapping_get_or_use(complex.aleo/arr_bool__, false, [false; 2]) : none);
            assert(b[0] == true);
            assert(b[1] == false);
            let n = _optional_unwrap(_mapping_contains(complex.aleo/nested__, false) ? _mapping_get_or_use(complex.aleo/nested__, false, [[0u8; 2]; 2]) : none);
            assert(n[0][1] == 2u8);
            assert(n[1][0] == 3u8);
        };
    }
    fn check2() -> Final<Fn()> {
        return async {
            let p = _optional_unwrap_or(_mapping_contains(complex.aleo/point__, false) ? _mapping_get_or_use(complex.aleo/point__, false, complex.aleo/Point { x: 0field, y: 0field }) : none, complex.aleo/Point { x: 0field, y: 0field });
            assert(p.x == 1field);
            assert(p.y == 2field);
            let ps = _optional_unwrap_or(_mapping_contains(complex.aleo/points__, false) ? _mapping_get_or_use(complex.aleo/points__, false, [complex.aleo/Point { x: 0field, y: 0field }; 2]) : none, [complex.aleo/Point { x: 0field, y: 0field }, complex.aleo/Point { x: 0field, y: 0field }]);
            assert(ps[0].x == 10field);
            assert(ps[1].y == 40field);
            let s = _optional_unwrap_or(_mapping_contains(complex.aleo/stats__, false) ? _mapping_get_or_use(complex.aleo/stats__, false, complex.aleo/Stats { values: [0u32; 3], active: false }) : none, complex.aleo/Stats { values: [0u32, 0u32, 0u32], active: false });
            assert(s.values[2] == 15u32);
            assert(s.active == true);
            let a = _optional_unwrap_or(_mapping_contains(complex.aleo/arr_u32__, false) ? _mapping_get_or_use(complex.aleo/arr_u32__, false, [0u32; 3]) : none, [0u32, 0u32, 0u32]);
            assert(a[1] == 8u32);
            let b = _optional_unwrap_or(_mapping_contains(complex.aleo/arr_bool__, false) ? _mapping_get_or_use(complex.aleo/arr_bool__, false, [false; 2]) : none, [false, false]);
            assert(b[0] == true);
            let n = _optional_unwrap_or(_mapping_contains(complex.aleo/nested__, false) ? _mapping_get_or_use(complex.aleo/nested__, false, [[0u8; 2]; 2]) : none, [[0u8, 0u8], [0u8, 0u8]]);
            assert(n[1][1] == 4u8);
        };
    }
}

